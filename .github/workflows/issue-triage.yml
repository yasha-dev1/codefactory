name: Issue Triage Agent

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  issues: write
  contents: read
  id-token: write

concurrency:
  group: issue-triage-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  triage:
    name: Triage Agent
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run triage guard
        id: guard
        env:
          ISSUE_JSON: ${{ toJSON(github.event.issue) }}
          EVENT_NAME: ${{ github.event.action }}
        run: |
          DECISION=$(npx tsx scripts/issue-triage-guard.ts --evaluate)
          echo "decision<<GUARD_EOF" >> "$GITHUB_OUTPUT"
          echo "$DECISION" >> "$GITHUB_OUTPUT"
          echo "GUARD_EOF" >> "$GITHUB_OUTPUT"

          SHOULD=$(echo "$DECISION" | jq -r '.shouldTriage')
          IS_RETRIAGE=$(echo "$DECISION" | jq -r '.isRetriage')
          REASON=$(echo "$DECISION" | jq -r '.reason')
          echo "should-triage=${SHOULD}" >> "$GITHUB_OUTPUT"
          echo "is-retriage=${IS_RETRIAGE}" >> "$GITHUB_OUTPUT"
          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"

          echo "Guard: shouldTriage=${SHOULD}, isRetriage=${IS_RETRIAGE}"

      - name: Skip ‚Äî log reason
        if: steps.guard.outputs.should-triage == 'false'
        run: |
          echo "::notice::Triage skipped: ${{ steps.guard.outputs.reason }}"

      - name: Ensure triage labels exist
        if: steps.guard.outputs.should-triage == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const labels = [
              { name: 'needs-more-info', color: 'FBCA04', description: 'Issue needs additional details' },
              { name: 'agent:implement', color: '0E8A16', description: 'Approved for automated implementation' },
              { name: 'triage:failed', color: 'D93F0B', description: 'Triage agent encountered an error' },
              { name: 'needs-human-review', color: 'C5DEF5', description: 'Requires human review before proceeding' },
            ];

            for (const label of labels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ...label,
                });
                core.info(`Created label: ${label.name}`);
              } catch {
                // Label already exists ‚Äî fine
              }
            }

      - name: Remove needs-more-info on re-triage
        if: steps.guard.outputs.is-retriage == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'needs-more-info',
              });
              core.info('Removed needs-more-info label for re-triage.');
            } catch {
              // Label might not exist ‚Äî fine
            }

      - name: Read triage prompt
        if: steps.guard.outputs.should-triage == 'true'
        id: prompt-file
        run: |
          if [[ -f ".codefactory/prompts/issue-triage.md" ]]; then
            {
              echo "content<<PROMPT_EOF"
              cat .codefactory/prompts/issue-triage.md
              echo "PROMPT_EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "content=Evaluate this issue for quality and actionability." >> "$GITHUB_OUTPUT"
          fi

      - name: Build triage prompt
        if: steps.guard.outputs.should-triage == 'true'
        id: build-prompt
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          TRIAGE_TEMPLATE: ${{ steps.prompt-file.outputs.content }}
          IS_RETRIAGE: ${{ steps.guard.outputs.is-retriage }}
        with:
          script: |
            const issue = context.payload.issue;
            const template = process.env.TRIAGE_TEMPLATE || '';
            const isRetriage = process.env.IS_RETRIAGE === 'true';
            const labels = (issue.labels || []).map((l) => l.name).join(', ');

            const prompt = [
              template,
              '',
              '## Issue to Triage',
              '',
              `**Number**: #${issue.number}`,
              `**Title**: ${issue.title}`,
              `**Author**: ${issue.user.login}`,
              `**Labels**: ${labels || 'none'}`,
              `**Re-triage**: ${isRetriage ? 'yes ‚Äî author updated the issue after needs-more-info' : 'no'}`,
              '',
              '### Body',
              '',
              issue.body || '*(empty body)*',
            ].join('\n');

            core.setOutput('prompt', prompt);
            core.info(`Triage prompt built (${prompt.length} chars)`);

      - name: Run Claude triage analysis
        if: steps.guard.outputs.should-triage == 'true'
        id: claude-triage
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: ${{ steps.build-prompt.outputs.prompt }}
          claude_args: '--max-turns 15'

      - name: Extract verdict from execution output
        if: steps.guard.outputs.should-triage == 'true'
        id: verdict
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          EXECUTION_FILE: ${{ steps.claude-triage.outputs.execution_file }}
        with:
          script: |
            const fs = require('fs');
            const execFile = process.env.EXECUTION_FILE || '';

            // --- Strategy 1: Read execution file ---
            let claudeText = '';
            if (execFile && fs.existsSync(execFile)) {
              try {
                const raw = fs.readFileSync(execFile, 'utf-8');

                // The execution file may be JSON or JSONL
                // Try single JSON object first
                try {
                  const data = JSON.parse(raw);
                  // Claude CLI result format: { type: "result", result: "..." }
                  if (data.result) {
                    claudeText = typeof data.result === 'string' ? data.result : JSON.stringify(data.result);
                  }
                } catch {
                  // Try JSONL ‚Äî scan each line for assistant messages or result
                  for (const line of raw.trim().split('\n')) {
                    try {
                      const msg = JSON.parse(line);
                      if (msg.type === 'result' && msg.result) {
                        claudeText = typeof msg.result === 'string' ? msg.result : JSON.stringify(msg.result);
                      } else if (msg.role === 'assistant' && msg.content) {
                        // Extract text from content blocks
                        const texts = (Array.isArray(msg.content) ? msg.content : [msg.content])
                          .filter(b => typeof b === 'string' || b.type === 'text')
                          .map(b => typeof b === 'string' ? b : b.text);
                        if (texts.length > 0) claudeText = texts.join('\n');
                      }
                    } catch {}
                  }
                }

                core.info(`Extracted ${claudeText.length} chars from execution file`);
              } catch (e) {
                core.warning(`Failed to read execution file: ${e.message}`);
              }
            } else {
              core.warning(`No execution file found at: ${execFile}`);
            }

            // --- Strategy 2: Fall back to reading the latest issue comment ---
            if (!claudeText) {
              core.info('Falling back to reading latest issue comment...');
              try {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  per_page: 10,
                });
                // Look for the most recent comment with JSON verdict (not our own marker comments)
                for (const c of comments.reverse()) {
                  if (c.body && c.body.includes('"actionable"') && !c.body.includes('<!-- issue-triage')) {
                    claudeText = c.body;
                    core.info('Found verdict in issue comment');
                    break;
                  }
                }
              } catch (e) {
                core.warning(`Failed to read issue comments: ${e.message}`);
              }
            }

            if (!claudeText) {
              core.warning('No Claude output found from execution file or comments');
              core.setOutput('parsed', 'false');
              core.setOutput('raw-text', '');
              return;
            }

            // --- Parse the JSON verdict ---
            let verdict = null;
            try {
              // Try to find a JSON object with "actionable" field
              const jsonMatch = claudeText.match(/\{[\s\S]*?"actionable"[\s\S]*?\}/);
              if (jsonMatch) {
                verdict = JSON.parse(jsonMatch[0]);
              }
            } catch (e) {
              core.warning(`JSON parse failed: ${e.message}`);
            }

            if (!verdict) {
              // Try stripping markdown fences
              try {
                const fenceMatch = claudeText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (fenceMatch) {
                  verdict = JSON.parse(fenceMatch[1].trim());
                }
              } catch {}
            }

            if (!verdict) {
              core.warning('Could not parse verdict JSON from Claude output');
              core.setOutput('parsed', 'false');
              // Store raw text for debugging in the route step
              const truncated = claudeText.slice(0, 2000);
              core.setOutput('raw-text', truncated);
              return;
            }

            core.setOutput('parsed', 'true');
            core.setOutput('actionable', String(verdict.actionable || false));
            core.setOutput('confidence', String(verdict.confidence || 0));
            core.setOutput('complexity', verdict.estimatedComplexity || 'medium');
            core.setOutput('summary', verdict.summary || '');
            core.setOutput('missing-info', JSON.stringify(verdict.missingInfo || []));
            core.setOutput('suggested-labels', JSON.stringify(verdict.suggestedLabels || []));

            const isBug = (verdict.suggestedLabels || []).some(
              (l) => l === 'bug' || l === 'ui-bug' || l === 'visual-bug'
            );
            core.setOutput('is-bug', String(isBug));
            core.setOutput('reproduced', String(verdict.reproduced || false));
            core.setOutput('reproduction-notes', verdict.reproductionNotes || '');
            core.setOutput('raw-text', '');

            core.info(`Verdict: actionable=${verdict.actionable}, confidence=${verdict.confidence}, complexity=${verdict.estimatedComplexity}, isBug=${isBug}`);

      - name: Install Chromium dependencies
        if: steps.verdict.outputs.is-bug == 'true' && steps.verdict.outputs.actionable == 'true'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq libnss3 libatk-bridge2.0-0 libdrm2 libxcomposite1 \
            libxdamage1 libxrandr2 libgbm1 libasound2t64 libpangocairo-1.0-0 libgtk-3-0 \
            libxshmfence1 2>/dev/null || true

      - name: Detect dev server command
        if: steps.verdict.outputs.is-bug == 'true' && steps.verdict.outputs.actionable == 'true'
        id: devserver
        run: |
          DEV_CMD=""
          if [[ -f "package.json" ]]; then
            for script in dev start serve; do
              HAS=$(jq -r ".scripts.\"${script}\" // empty" package.json)
              if [[ -n "$HAS" ]]; then
                DEV_CMD="npm run ${script}"
                break
              fi
            done
          fi

          if [[ -n "$DEV_CMD" ]]; then
            echo "cmd=${DEV_CMD}" >> "$GITHUB_OUTPUT"
            echo "available=true" >> "$GITHUB_OUTPUT"
            echo "Dev server command: ${DEV_CMD}"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo "::notice::No dev server script found ‚Äî skipping browser reproduction."
          fi

      - name: Browser reproduction phase
        if: >-
          steps.verdict.outputs.is-bug == 'true' &&
          steps.verdict.outputs.actionable == 'true' &&
          steps.devserver.outputs.available == 'true'
        id: reproduce
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: |
            You are a bug reproduction agent. Your goal is to reproduce a reported bug using a headless browser.

            ## Issue
            **Title**: ${{ github.event.issue.title }}
            **Body**: ${{ github.event.issue.body }}

            ## Instructions

            1. Install puppeteer: `npm install puppeteer`
            2. Start the dev server in the background: `${{ steps.devserver.outputs.cmd }} &`
            3. Wait for the server to be ready (poll http://localhost:3000 or the appropriate port)
            4. Write a Puppeteer script that attempts to reproduce the bug described in the issue
            5. Take screenshots at key steps and save them to `/tmp/repro-screenshots/`
            6. Run the script and observe the results
            7. Clean up (kill the dev server)

            ## Output

            Return ONLY a JSON object:
            ```json
            {
              "reproduced": true/false,
              "screenshots": ["list of screenshot file paths"],
              "notes": "Brief description of what you observed"
            }
            ```
          claude_args: '--max-turns 20'

      - name: Parse reproduction result
        if: steps.reproduce.outcome == 'success'
        id: repro-result
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          REPRO_EXECUTION_FILE: ${{ steps.reproduce.outputs.execution_file }}
        with:
          script: |
            const fs = require('fs');
            const execFile = process.env.REPRO_EXECUTION_FILE || '';
            let text = '';

            if (execFile && fs.existsSync(execFile)) {
              try {
                const raw = fs.readFileSync(execFile, 'utf-8');
                try {
                  const data = JSON.parse(raw);
                  if (data.result) text = typeof data.result === 'string' ? data.result : JSON.stringify(data.result);
                } catch {
                  for (const line of raw.trim().split('\n').reverse()) {
                    try {
                      const msg = JSON.parse(line);
                      if (msg.type === 'result' && msg.result) {
                        text = typeof msg.result === 'string' ? msg.result : JSON.stringify(msg.result);
                        break;
                      }
                    } catch {}
                  }
                }
              } catch {}
            }

            try {
              const match = text.match(/\{[\s\S]*?"reproduced"[\s\S]*?\}/);
              if (match) {
                const result = JSON.parse(match[0]);
                core.setOutput('reproduced', String(result.reproduced || false));
                core.setOutput('notes', result.notes || '');
                core.info(`Reproduction result: reproduced=${result.reproduced}`);
                return;
              }
            } catch (e) {
              core.warning(`Failed to parse reproduction result: ${e.message}`);
            }
            core.setOutput('reproduced', 'false');
            core.setOutput('notes', 'Reproduction phase did not produce parseable output.');

      - name: Route triage decision
        if: steps.guard.outputs.should-triage == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          PARSED: ${{ steps.verdict.outputs.parsed }}
          ACTIONABLE: ${{ steps.verdict.outputs.actionable }}
          CONFIDENCE: ${{ steps.verdict.outputs.confidence }}
          COMPLEXITY: ${{ steps.verdict.outputs.complexity }}
          SUMMARY: ${{ steps.verdict.outputs.summary }}
          MISSING_INFO: ${{ steps.verdict.outputs.missing-info }}
          SUGGESTED_LABELS: ${{ steps.verdict.outputs.suggested-labels }}
          IS_BUG: ${{ steps.verdict.outputs.is-bug }}
          REPRO_RAN: ${{ steps.reproduce.outcome || 'skipped' }}
          REPRODUCED: ${{ steps.repro-result.outputs.reproduced || 'false' }}
          REPRO_NOTES: ${{ steps.repro-result.outputs.notes || '' }}
          RAW_TEXT: ${{ steps.verdict.outputs.raw-text }}
        with:
          script: |
            const issueNumber = context.issue.number;
            const parsed = process.env.PARSED === 'true';
            const actionable = process.env.ACTIONABLE === 'true';
            const confidence = parseFloat(process.env.CONFIDENCE || '0');
            const complexity = process.env.COMPLEXITY || 'medium';
            const summary = process.env.SUMMARY || '';
            const isBug = process.env.IS_BUG === 'true';
            const reproRan = process.env.REPRO_RAN === 'success';
            const reproduced = process.env.REPRODUCED === 'true';
            const reproNotes = process.env.REPRO_NOTES || '';
            const rawText = process.env.RAW_TEXT || '';

            let missingInfo = [];
            let suggestedLabels = [];
            try { missingInfo = JSON.parse(process.env.MISSING_INFO || '[]'); } catch {}
            try { suggestedLabels = JSON.parse(process.env.SUGGESTED_LABELS || '[]'); } catch {}

            const labelsToAdd = [];
            const commentSections = [`<!-- issue-triage: #${issueNumber} -->`];

            if (!parsed) {
              // Failed to parse ‚Äî add failure label and show what Claude said
              labelsToAdd.push('triage:failed');
              commentSections.push(
                '## ‚ö†Ô∏è Issue Triage ‚Äî Parse Failure',
                '',
                'The triage agent could not produce a valid verdict for this issue.',
                'A human should review and triage manually.',
              );
              if (rawText) {
                commentSections.push(
                  '',
                  '<details><summary>Agent raw output (for debugging)</summary>',
                  '',
                  '```',
                  rawText.slice(0, 1500),
                  '```',
                  '',
                  '</details>',
                );
              }
            } else if (actionable) {
              let shouldImplement = confidence >= 0.7;

              // Bug reproduction boost
              if (isBug && reproRan) {
                if (reproduced) {
                  shouldImplement = true;
                  commentSections.push(
                    '## ‚úÖ Issue Triage ‚Äî Bug Confirmed',
                    '',
                    `**Summary**: ${summary}`,
                    `**Confidence**: ${confidence} (boosted ‚Äî bug reproduced)`,
                    `**Complexity**: ${complexity}`,
                  );
                  if (reproNotes) {
                    commentSections.push('', `**Reproduction notes**: ${reproNotes}`);
                  }
                } else {
                  shouldImplement = false;
                  labelsToAdd.push('needs-more-info');
                  commentSections.push(
                    '## üîç Issue Triage ‚Äî Bug Not Reproduced',
                    '',
                    `**Summary**: ${summary}`,
                    `**Confidence**: ${confidence}`,
                    '',
                    'The automated reproduction attempt could not confirm this bug.',
                    'Please provide more detailed reproduction steps, including:',
                    '- Exact URL/page where the issue occurs',
                    '- Browser and OS version',
                    '- Step-by-step actions to trigger the bug',
                  );
                  if (reproNotes) {
                    commentSections.push('', `**Agent notes**: ${reproNotes}`);
                  }
                }
              } else if (shouldImplement) {
                commentSections.push(
                  '## ‚úÖ Issue Triage ‚Äî Approved for Implementation',
                  '',
                  `**Summary**: ${summary}`,
                  `**Confidence**: ${confidence}`,
                  `**Complexity**: ${complexity}`,
                );
              } else {
                // Actionable but low confidence ‚Äî ask clarifying questions
                labelsToAdd.push('needs-more-info');
                const missingItems = missingInfo.length > 0
                  ? missingInfo.map((m) => `- ${m}`)
                  : ['- More details about the expected behavior', '- Steps to reproduce or context'];
                commentSections.push(
                  '## üîç Issue Triage ‚Äî More Details Needed',
                  '',
                  `**Summary**: ${summary}`,
                  `**Confidence**: ${confidence} (below 0.7 threshold)`,
                  '',
                  'To help the implementation agent, please clarify:',
                  ...missingItems,
                );
              }

              if (shouldImplement) {
                labelsToAdd.push('agent:implement');
              }

              if (complexity === 'high') {
                labelsToAdd.push('needs-human-review');
              }
            } else {
              // Not actionable ‚Äî ask clarifying questions
              labelsToAdd.push('needs-more-info');
              const missingItems = missingInfo.length > 0
                ? missingInfo.map((m) => `- ${m}`)
                : ['- A clear description of what you expect to happen', '- Steps to reproduce the issue'];
              commentSections.push(
                '## üìã Issue Triage ‚Äî Not Actionable',
                '',
                `**Summary**: ${summary || 'Unable to determine issue intent'}`,
                '',
                'This issue needs more information before it can be implemented. Please provide:',
                ...missingItems,
                '',
                '*Edit this issue with the requested details and we will re-evaluate automatically.*',
              );
            }

            // Add suggested labels (filter out internal ones)
            const internalLabels = ['agent:implement', 'needs-more-info', 'triage:failed', 'needs-human-review'];
            for (const label of suggestedLabels) {
              if (!internalLabels.includes(label) && !labelsToAdd.includes(label)) {
                try {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: 'EDEDED',
                  });
                } catch {}
                labelsToAdd.push(label);
              }
            }

            // Apply labels
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: labelsToAdd,
              });
              core.info(`Added labels: ${labelsToAdd.join(', ')}`);
            }

            // Post comment
            commentSections.push(
              '',
              '---',
              '*ü§ñ [Issue Triage Agent](https://github.com/codefactory) ‚Äî automated issue triage.*',
            );

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: commentSections.join('\n'),
            });

      - name: Failure handler
        if: failure() && steps.guard.outputs.should-triage == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const issueNumber = context.issue.number;

            try {
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'triage:failed',
                color: 'D93F0B',
                description: 'Triage agent encountered an error',
              });
            } catch {}

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: ['triage:failed'],
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: [
                `<!-- issue-triage-failed: #${issueNumber} -->`,
                '## ‚ùå Issue Triage ‚Äî Agent Error',
                '',
                'The triage agent encountered an unexpected error while processing this issue.',
                'A human should review and triage manually.',
                '',
                `**Run**: [${context.runId}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
                '',
                '---',
                '*ü§ñ [Issue Triage Agent](https://github.com/codefactory) ‚Äî automated issue triage.*',
              ].join('\n'),
            });
