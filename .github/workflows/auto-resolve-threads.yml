name: Auto-Resolve Bot Threads

on:
  check_run:
    types: [completed]

permissions:
  contents: read
  pull-requests: write

jobs:
  auto-resolve:
    name: Resolve Stale Bot Threads
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: >-
      github.event.check_run.name == 'review-agent' &&
      github.event.check_run.conclusion == 'success'
    steps:
      - name: Checkout at reviewed SHA
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          ref: ${{ github.event.check_run.head_sha }}

      - name: Resolve bot-only threads
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headSha = context.payload.check_run.head_sha;

            // Find the PR associated with this check run
            const prs = context.payload.check_run.pull_requests || [];
            if (prs.length === 0) {
              core.info('No PRs associated with this check run â€” nothing to resolve.');
              return;
            }

            const prNumber = prs[0].number;
            core.info(`Processing PR #${prNumber} at SHA ${headSha.slice(0, 12)}`);

            // Bot login patterns for the review agent
            const BOT_LOGINS = ['github-actions[bot]', 'github-actions', 'dependabot[bot]'];
            const isBot = (login) => BOT_LOGINS.includes(login) || login.endsWith('[bot]');

            // Verify this check run is for the current HEAD SHA
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (pr.head.sha !== headSha) {
              core.info(`Check run SHA (${headSha.slice(0, 12)}) â‰  PR HEAD (${pr.head.sha.slice(0, 12)}) â€” stale result, skipping.`);
              return;
            }

            // Fetch all reviews to find review threads
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner, repo, pull_number: prNumber, per_page: 100,
            });

            // Fetch all review comments (inline thread comments)
            const reviewComments = await github.paginate(
              github.rest.pulls.listReviewComments,
              { owner, repo, pull_number: prNumber, per_page: 100 },
            );

            // Group comments by their thread (in_reply_to_id or own id)
            const threads = new Map();
            for (const comment of reviewComments) {
              const threadId = comment.in_reply_to_id || comment.id;
              if (!threads.has(threadId)) {
                threads.set(threadId, []);
              }
              threads.get(threadId).push(comment);
            }

            let resolvedCount = 0;

            for (const [threadId, comments] of threads) {
              // Check if all comments in this thread are from bots
              const allBot = comments.every((c) => isBot(c.user?.login || ''));
              if (!allBot) {
                core.info(`Thread ${threadId}: has human comments â€” preserving.`);
                continue;
              }

              // Check if any comment in the thread is unresolved
              // (GitHub doesn't expose resolved state via REST â€” use GraphQL)
              // For REST API, we minimize threads by hiding outdated bot comments
              const rootComment = comments.find((c) => !c.in_reply_to_id) || comments[0];

              // Only resolve if the thread is from a prior review (not current SHA)
              // This ensures we don't resolve threads just posted
              const commentSha = rootComment.original_commit_id || rootComment.commit_id;
              if (commentSha === headSha) {
                core.info(`Thread ${threadId}: from current SHA â€” skipping (too new).`);
                continue;
              }

              // Minimize the root comment to indicate it's been addressed
              try {
                // Use GraphQL to minimize/resolve the comment
                await github.graphql(`
                  mutation($id: ID!) {
                    minimizeComment(input: { subjectId: $id, classifier: RESOLVED }) {
                      minimizedComment { isMinimized }
                    }
                  }
                `, { id: rootComment.node_id });

                resolvedCount++;
                core.info(`Thread ${threadId}: auto-resolved (bot-only, addressed in ${headSha.slice(0, 12)}).`);
              } catch (error) {
                core.warning(`Failed to resolve thread ${threadId}: ${error.message}`);
              }
            }

            if (resolvedCount > 0) {
              // Post a summary comment
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: [
                  `<!-- harness-auto-resolve: ${headSha} -->`,
                  `ðŸ§¹ Auto-resolved **${resolvedCount}** bot-only review thread${resolvedCount === 1 ? '' : 's'} addressed in commit \`${headSha.slice(0, 12)}\`.`,
                  '',
                  '_Threads with human comments are preserved. Only bot-originated threads from prior commits were resolved._',
                ].join('\n'),
              });

              core.info(`Auto-resolved ${resolvedCount} bot threads.`);
            } else {
              core.info('No bot-only threads to resolve.');
            }
