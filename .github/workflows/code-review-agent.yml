name: Code Review Agent

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  actions: write
  id-token: write

concurrency:
  group: review-agent-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  review:
    name: Review Agent
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout at PR head SHA
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Determine risk tier
        id: tier
        run: |
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          # Verify SHA discipline
          ACTUAL_SHA="$(git rev-parse HEAD)"
          if [[ "${ACTUAL_SHA,,}" != "${HEAD_SHA,,}" ]]; then
            echo "::error::SHA discipline violation: HEAD (${ACTUAL_SHA}) ‚â† expected (${HEAD_SHA})"
            exit 1
          fi

          # Ensure base ref is available
          if ! git rev-parse --verify "origin/${BASE_REF}" &>/dev/null; then
            git fetch origin "${BASE_REF}" --depth=1 2>/dev/null || true
          fi

          MERGE_BASE="$(git merge-base "origin/${BASE_REF}" HEAD 2>/dev/null || echo "")"
          if [[ -z "$MERGE_BASE" ]]; then
            echo "tier=3" >> "$GITHUB_OUTPUT"
            echo "changed-files=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          CHANGED="$(git diff --name-only "${MERGE_BASE}...HEAD" 2>/dev/null || echo "")"
          if [[ -z "$CHANGED" ]]; then
            echo "tier=1" >> "$GITHUB_OUTPUT"
            echo "changed-files=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          TIER=1
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            case "$file" in
              src/index.ts|src/cli.ts|package.json|tsconfig.json|tsup.config.ts|vitest.config.ts|eslint.config.js)
                TIER=3 ;;
              src/commands/*.ts|src/core/*.ts|src/harnesses/index.ts|src/harnesses/types.ts)
                [[ $TIER -lt 3 ]] && TIER=3 ;;
              src/*.ts|tests/*.ts|scripts/*.ts|*.ts|*.js|*.mjs)
                [[ $TIER -lt 2 ]] && TIER=2 ;;
            esac
          done <<< "$CHANGED"

          echo "tier=${TIER}" >> "$GITHUB_OUTPUT"

          # Serialize changed files for the review prompt
          {
            echo "changed-files<<CEOF"
            echo "$CHANGED"
            echo "CEOF"
          } >> "$GITHUB_OUTPUT"

          echo "‚úî Tier ${TIER} ‚Äî $(echo "$CHANGED" | wc -l) files changed"

      - name: Skip if Tier 1
        if: steps.tier.outputs.tier == '1'
        run: echo "Tier 1 change ‚Äî review agent not required. Skipping."

      - name: SHA deduplication check
        if: steps.tier.outputs.tier != '1'
        id: dedup
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const marker = `<!-- harness-review: ${headSha} -->`;
            const prNumber = context.payload.pull_request.number;

            core.info(`Checking for existing review of SHA ${headSha.slice(0, 12)}...`);

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const alreadyReviewed = comments.some((c) => c.body?.includes(marker));
            if (alreadyReviewed) {
              core.info(`SHA ${headSha.slice(0, 12)} already reviewed ‚Äî skipping.`);
              core.setOutput('skip', 'true');
            } else {
              core.info(`No existing review for SHA ${headSha.slice(0, 12)} ‚Äî proceeding.`);
              core.setOutput('skip', 'false');
            }

      - name: Create in-progress check run
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: check
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const { data: checkRun } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'review-agent',
              head_sha: headSha,
              status: 'in_progress',
              started_at: new Date().toISOString(),
              output: {
                title: 'Code Review Agent',
                summary: 'Review in progress...',
              },
            });
            core.setOutput('check-run-id', checkRun.id);
            core.info(`Created check run ${checkRun.id} for SHA ${headSha.slice(0, 12)}`);

      - name: Read review prompt
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: prompt-file
        run: |
          if [[ -f "scripts/review-prompt.md" ]]; then
            {
              echo "content<<PROMPT_EOF"
              cat scripts/review-prompt.md
              echo "PROMPT_EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "content=Review this pull request for bugs, security issues, and architectural violations." >> "$GITHUB_OUTPUT"
          fi

      - name: Build review prompt
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: build-prompt
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          REVIEW_TEMPLATE: ${{ steps.prompt-file.outputs.content }}
          TIER: ${{ steps.tier.outputs.tier }}
          CHANGED_FILES: ${{ steps.tier.outputs.changed-files }}
        with:
          script: |
            const fs = require('fs');
            const template = process.env.REVIEW_TEMPLATE || '';
            const tier = process.env.TIER || '2';
            const changedFiles = process.env.CHANGED_FILES || '';

            let conventions = '';
            try { conventions = fs.readFileSync('CLAUDE.md', 'utf-8').slice(0, 6000); } catch {}

            let config = '';
            try { config = fs.readFileSync('harness.config.json', 'utf-8'); } catch {}

            const sections = [
              template,
              '',
              '## PR Context',
              '',
              `**Risk Tier**: Tier ${tier}`,
              `**Changed Files**:`,
              changedFiles ? changedFiles.split('\n').map(f => `- ${f}`).join('\n') : '*(none detected)*',
              '',
              '## Project Conventions (from CLAUDE.md)',
              '',
              conventions || 'No CLAUDE.md found.',
              '',
              '## Harness Configuration',
              '',
              '```json',
              config || '{}',
              '```',
            ];

            const prompt = sections.join('\n');
            core.setOutput('prompt', prompt);
            core.info(`Review prompt built (${prompt.length} chars)`);

      - name: Run Claude review
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: review
        # OIDC validation requires the workflow file to match main exactly.
        # PRs that modify this workflow file will always fail the OIDC exchange ‚Äî
        # that is expected and correct (prevents permission escalation). We use
        # continue-on-error so the job still completes and the check run is marked
        # neutral rather than hard-failing the PR.
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: ${{ steps.build-prompt.outputs.prompt }}
          claude_args: '--max-turns 100 --allowedTools "Read,Glob,Grep,Bash"'
          allowed_bots: 'github-actions,implementer-bot'

      - name: Extract review from execution file
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: extract
        env:
          EXECUTION_FILE: ${{ steps.review.outputs.execution_file }}
        run: |
          if [[ -z "$EXECUTION_FILE" || ! -f "$EXECUTION_FILE" ]]; then
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "::warning::No execution file available"
            exit 0
          fi

          echo "Execution file: ${EXECUTION_FILE} ($(wc -c < "$EXECUTION_FILE") bytes)"

          # The execution file is a JSON array (not JSONL) from Claude Code SDK.
          # It contains a "result" turn at the end with the final response text.
          # Fallback: extract last assistant text content from message turns.
          REVIEW_TEXT=$(jq -r '
            [.[] | select(.type == "result")] | last | .result // ""
          ' "$EXECUTION_FILE" 2>/dev/null || echo "")

          # Fallback: if result turn is empty, get last assistant text
          if [[ -z "$REVIEW_TEXT" || "$REVIEW_TEXT" == "null" ]]; then
            REVIEW_TEXT=$(jq -r '
              [.[] | select(.type == "assistant") |
               .message.content[] | select(.type == "text") | .text
              ] | last // ""
            ' "$EXECUTION_FILE" 2>/dev/null || echo "")
          fi

          if [[ -z "$REVIEW_TEXT" || "$REVIEW_TEXT" == "null" ]]; then
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Could not extract review text from execution file"
          else
            # Truncate to 60000 chars to stay within GitHub comment limits
            REVIEW_TEXT="${REVIEW_TEXT:0:60000}"
            {
              echo "review<<REVIEW_EOF"
              echo "$REVIEW_TEXT"
              echo "REVIEW_EOF"
            } >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "‚úî Extracted review ($(echo "$REVIEW_TEXT" | wc -c) chars)"
          fi

      - name: Parse verdict from review
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: verdict
        env:
          REVIEW_TEXT: ${{ steps.extract.outputs.review || '' }}
          REVIEW_FOUND: ${{ steps.extract.outputs.found || 'false' }}
        run: |
          REVIEW_TEXT="${REVIEW_TEXT}"
          if [[ "$REVIEW_FOUND" != "true" || -z "$REVIEW_TEXT" ]]; then
            echo "verdict=COMMENT" >> "$GITHUB_OUTPUT"
            echo "Verdict: COMMENT (no review text)"
            exit 0
          fi

          # Try JSON parse first ‚Äî review-prompt.md requests JSON output
          VERDICT=$(echo "$REVIEW_TEXT" | jq -r '.verdict // empty' 2>/dev/null || echo "")

          # Fallback: regex scan for VERDICT: line or **Verdict**: line
          if [[ -z "$VERDICT" ]]; then
            VERDICT=$(echo "$REVIEW_TEXT" | grep -oP '(?i)\*?\*?verdict\*?\*?\s*:?\s*(APPROVE|REQUEST_CHANGES|COMMENT)' | head -1 | grep -oP '(APPROVE|REQUEST_CHANGES|COMMENT)' || echo "")
          fi

          # Default to COMMENT if extraction failed (safe ‚Äî no automated action)
          if [[ -z "$VERDICT" ]]; then
            VERDICT="COMMENT"
            echo "::notice::Could not extract verdict from review ‚Äî defaulting to COMMENT."
          fi

          echo "verdict=${VERDICT}" >> "$GITHUB_OUTPUT"
          echo "Verdict: ${VERDICT}"

      - name: Post review marker
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          REVIEW_TEXT: ${{ steps.extract.outputs.review || '' }}
          REVIEW_FOUND: ${{ steps.extract.outputs.found || 'false' }}
          REVIEW_OUTCOME: ${{ steps.review.outcome }}
          VERDICT: ${{ steps.verdict.outputs.verdict || 'COMMENT' }}
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const marker = `<!-- harness-review: ${headSha} -->`;
            const verdictMarker = `<!-- review-verdict: ${process.env.VERDICT} -->`;
            const tier = '${{ steps.tier.outputs.tier }}';
            const reviewText = process.env.REVIEW_TEXT || '';
            const reviewFound = process.env.REVIEW_FOUND === 'true';
            const reviewOutcome = process.env.REVIEW_OUTCOME || 'failure';
            const verdict = process.env.VERDICT || 'COMMENT';

            const verdictEmoji = verdict === 'APPROVE' ? '‚úÖ' : verdict === 'REQUEST_CHANGES' ? 'üîÑ' : 'üí¨';

            const sections = [
              marker,
              verdictMarker,
              `## üîç Code Review Agent ‚Äî Tier ${tier}`,
              '',
              `**Commit**: \`${headSha.slice(0, 12)}\``,
              `**Status**: ${reviewOutcome === 'success' ? '‚úÖ Complete' : '‚ö†Ô∏è Review may be incomplete'}`,
              `**Verdict**: ${verdictEmoji} ${verdict}`,
            ];

            if (reviewFound && reviewText) {
              sections.push('', '### Review', '', reviewText);
            } else {
              sections.push('', '*No review output was produced. The review agent may have encountered an error.*');
            }

            sections.push(
              '',
              '---',
              '*ü§ñ [Code Review Agent](https://github.com/codefactory) ‚Äî automated code review.*',
            );

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: sections.join('\n'),
            });

      - name: Complete check run
        if: always() && steps.check.outputs.check-run-id
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          CHECK_RUN_ID: ${{ steps.check.outputs.check-run-id }}
          REVIEW_OUTCOME: ${{ steps.review.outcome }}
        with:
          script: |
            const checkRunId = parseInt(process.env.CHECK_RUN_ID);
            const reviewOutcome = process.env.REVIEW_OUTCOME || 'failure';
            const conclusion = reviewOutcome === 'success' ? 'success' : 'neutral';

            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'completed',
              conclusion,
              completed_at: new Date().toISOString(),
              output: {
                title: `Review Agent ‚Äî ${conclusion === 'success' ? 'Complete' : 'Review Needed'}`,
                summary: `Claude Code review completed with outcome: ${reviewOutcome}`,
              },
            });

            core.info(`Check run ${checkRunId} completed: ${conclusion}`);

      - name: Check review-fix eligibility
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true' && steps.verdict.outputs.verdict == 'REQUEST_CHANGES'
        id: review-fix
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const prLabels = pr.labels.map(l => l.name);

            // Only auto-fix agent-created PRs
            if (!prLabels.includes('agent-pr')) {
              core.info('PR does not have agent-pr label ‚Äî skipping review-fix dispatch.');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Not an agent-created PR');
              return;
            }

            // Skip if already escalated
            if (prLabels.includes('agent:needs-judgment')) {
              core.info('PR already has agent:needs-judgment label ‚Äî skipping.');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Already escalated');
              return;
            }

            // Count review-fix-cycle-N labels to determine cycle number
            let maxCycle = 0;
            for (const label of prLabels) {
              const match = label.match(/^review-fix-cycle-(\d+)$/);
              if (match) {
                const n = parseInt(match[1], 10);
                if (n > maxCycle) maxCycle = n;
              }
            }
            const nextCycle = maxCycle + 1;

            if (nextCycle > 3) {
              core.info(`Max review-fix cycles reached (${maxCycle} cycles). Escalating.`);
              core.setOutput('eligible', 'false');
              core.setOutput('escalate', 'true');
              core.setOutput('reason', `Max cycles exceeded (${maxCycle})`);
              return;
            }

            // Extract linked issue number from PR body marker
            const prBody = pr.body || '';
            const issueMatch = prBody.match(/<!-- issue-implementer: #(\d+) -->/);
            const issueNumber = issueMatch ? issueMatch[1] : '';

            core.setOutput('eligible', 'true');
            core.setOutput('escalate', 'false');
            core.setOutput('cycle', String(nextCycle));
            core.setOutput('issue-number', issueNumber);
            core.info(`Review-fix eligible: cycle ${nextCycle}, issue #${issueNumber || 'unknown'}`);

      - name: Escalate ‚Äî max review-fix cycles
        if: steps.review-fix.outputs.escalate == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const prNumber = context.payload.pull_request.number;

            // Create label if it doesn't exist
            try {
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'agent:needs-judgment',
                color: 'E4E669',
                description: 'Agent needs human judgment to proceed',
              });
            } catch {}

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ['agent:needs-judgment'],
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: [
                '## ‚ö†Ô∏è Review-Fix Loop ‚Äî Max Cycles Reached',
                '',
                'The automated review-fix cycle has reached the maximum of 3 attempts.',
                'A human should review the remaining issues and decide next steps.',
                '',
                `**Run**: [${context.runId}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
                '',
                '---',
                '*ü§ñ [Code Review Agent](https://github.com/codefactory) ‚Äî automated code review.*',
              ].join('\n'),
            });

      - name: Dispatch implementer for review-fix
        if: steps.review-fix.outputs.eligible == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUM: ${{ github.event.pull_request.number }}
          CYCLE: ${{ steps.review-fix.outputs.cycle }}
        run: |
          echo "Dispatching implementer for review-fix: PR #${PR_NUM}, cycle ${CYCLE}"
          gh workflow run issue-implementer.yml \
            --repo "${{ github.repository }}" \
            --field pr_number="${PR_NUM}" \
            --field review_fix_cycle="${CYCLE}"
          echo "‚úî Dispatched issue-implementer.yml for review-fix"

      - name: Report skip as success
        if: steps.tier.outputs.tier == '1' || steps.dedup.outputs.skip == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const headSha = context.payload.pull_request.head.sha;
            const tier = '${{ steps.tier.outputs.tier }}';
            const skipped = '${{ steps.dedup.outputs.skip }}' === 'true';
            const reason = tier === '1' ? 'Tier 1 ‚Äî review not required' : `SHA ${headSha.slice(0, 12)} already reviewed`;

            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'review-agent',
              head_sha: headSha,
              status: 'completed',
              conclusion: 'success',
              completed_at: new Date().toISOString(),
              output: {
                title: `Review Agent ‚Äî Skipped`,
                summary: reason,
              },
            });

            core.info(`Review skipped: ${reason}`);
