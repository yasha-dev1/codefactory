import type { HarnessModule, HarnessContext, HarnessOutput } from './types.js';

import { buildReviewAgentPrompt } from '../prompts/review-agent.js';
import { buildSystemPrompt } from '../prompts/system.js';

export const reviewAgentHarness: HarnessModule = {
  name: 'review-agent',
  displayName: 'Review Agent Integration',
  description: 'Generates code review agent workflows with SHA-deduped reruns and auto-resolve',
  order: 7,

  isApplicable(): boolean {
    return true;
  },

  async execute(ctx: HarnessContext): Promise<HarnessOutput> {
    const { detection, userPreferences } = ctx;

    // 1. Generate reference templates from existing builders
    const refCodeReviewWorkflow = buildCodeReviewWorkflow();
    const refRerunWorkflow = buildRerunWorkflow();
    const refAutoResolveWorkflow = buildAutoResolveWorkflow();
    const refReviewAgentUtils = buildReviewAgentUtils();
    const refReviewPrompt = buildReviewPrompt();
    const refCodefactoryPrompt = buildCodefactoryPrompt();

    // 2. Build the prompt with reference context
    const basePrompt = buildReviewAgentPrompt(detection, userPreferences);
    const prompt = `${basePrompt}

## Reference Implementation

Use these as your structural template. Keep the same patterns but customize all
language setup, install commands, test/lint/build commands, and tooling for the
detected stack.

### Reference: .github/workflows/code-review-agent.yml
\`\`\`yaml
${refCodeReviewWorkflow}
\`\`\`

### Reference: .github/workflows/review-agent-rerun.yml
\`\`\`yaml
${refRerunWorkflow}
\`\`\`

### Reference: .github/workflows/auto-resolve-threads.yml
\`\`\`yaml
${refAutoResolveWorkflow}
\`\`\`

### Reference: scripts/review-agent-utils.ts
\`\`\`typescript
${refReviewAgentUtils}
\`\`\`

### Reference: scripts/review-prompt.md
\`\`\`markdown
${refReviewPrompt}
\`\`\`

### Reference: .codefactory/prompts/review-agent.md
\`\`\`markdown
${refCodefactoryPrompt}
\`\`\``;

    // 3. Call Claude runner
    const systemPrompt = buildSystemPrompt();
    try {
      const result = await ctx.runner.generate(prompt, systemPrompt);
      const output: HarnessOutput = {
        harnessName: 'review-agent',
        filesCreated: result.filesCreated,
        filesModified: result.filesModified,
        metadata: { reviewWorkflowPath: '.github/workflows/code-review.yml' },
      };
      ctx.previousOutputs.set('review-agent', output);
      return output;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Review agent generation failed: ${message}`);
    }
  },
};

// ‚îÄ‚îÄ File builders ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function buildCodeReviewWorkflow(): string {
  const lines = [
    'name: Code Review Agent',
    '',
    'on:',
    '  pull_request:',
    '    types: [opened, synchronize]',
    '  workflow_dispatch:',
    '    inputs:',
    '      pr_number:',
    "        description: 'PR number to review (used after review-fix push)'",
    '        required: true',
    '        type: string',
    '',
    'permissions:',
    '  contents: read',
    '  pull-requests: write',
    '  checks: write',
    '  issues: write',
    '  actions: write',
    '  id-token: write',
    '',
    'concurrency:',
    '  group: review-agent-${{ github.event.pull_request.number || inputs.pr_number }}',
    '  cancel-in-progress: true',
    '',
    'jobs:',
    '  review:',
    '    name: Review Agent',
    '    runs-on: ubuntu-latest',
    '    timeout-minutes: 15',
    '    steps:',
    '      - name: Checkout at PR head SHA',
    '        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2',
    '        with:',
    "          ref: ${{ github.event.pull_request.head.sha || '' }}",
    '          fetch-depth: 0',
    '',
    '      - name: Resolve PR context',
    '        id: pr',
    '        env:',
    '          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}',
    '        run: |',
    '          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then',
    '            PR_NUMBER="${{ inputs.pr_number }}"',
    '            PR_JSON=$(gh pr view "$PR_NUMBER" --json headRefOid,baseRefName,number)',
    '            HEAD_SHA=$(echo "$PR_JSON" | jq -r \'.headRefOid\')',
    '            BASE_REF=$(echo "$PR_JSON" | jq -r \'.baseRefName\')',
    '',
    '            # Re-checkout at the PR head SHA',
    '            git fetch origin "$HEAD_SHA"',
    '            git checkout "$HEAD_SHA"',
    '            echo "‚úî Resolved PR #${PR_NUMBER} at ${HEAD_SHA:0:12} (workflow_dispatch)"',
    '          else',
    '            HEAD_SHA="${{ github.event.pull_request.head.sha }}"',
    '            BASE_REF="${{ github.event.pull_request.base.ref }}"',
    '            PR_NUMBER="${{ github.event.pull_request.number }}"',
    '          fi',
    '',
    '          echo "head-sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"',
    '          echo "base-ref=${BASE_REF}" >> "$GITHUB_OUTPUT"',
    '          echo "pr-number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"',
    '',
    '      - name: Determine risk tier',
    '        id: tier',
    '        run: |',
    '          BASE_REF="${{ steps.pr.outputs.base-ref }}"',
    '          HEAD_SHA="${{ steps.pr.outputs.head-sha }}"',
    '',
    '          # Verify SHA discipline',
    '          ACTUAL_SHA="$(git rev-parse HEAD)"',
    '          if [[ "${ACTUAL_SHA,,}" != "${HEAD_SHA,,}" ]]; then',
    '            echo "::error::SHA discipline violation: HEAD (${ACTUAL_SHA}) ‚â† expected (${HEAD_SHA})"',
    '            exit 1',
    '          fi',
    '',
    '          # Ensure base ref is available',
    '          if ! git rev-parse --verify "origin/${BASE_REF}" &>/dev/null; then',
    '            git fetch origin "${BASE_REF}" --depth=1 2>/dev/null || true',
    '          fi',
    '',
    '          MERGE_BASE="$(git merge-base "origin/${BASE_REF}" HEAD 2>/dev/null || echo "")"',
    '          if [[ -z "$MERGE_BASE" ]]; then',
    '            echo "tier=3" >> "$GITHUB_OUTPUT"',
    '            echo "changed-files=" >> "$GITHUB_OUTPUT"',
    '            exit 0',
    '          fi',
    '',
    '          CHANGED="$(git diff --name-only "${MERGE_BASE}...HEAD" 2>/dev/null || echo "")"',
    '          if [[ -z "$CHANGED" ]]; then',
    '            echo "tier=1" >> "$GITHUB_OUTPUT"',
    '            echo "changed-files=" >> "$GITHUB_OUTPUT"',
    '            exit 0',
    '          fi',
    '',
    '          TIER=1',
    '          while IFS= read -r file; do',
    '            [[ -z "$file" ]] && continue',
    '            case "$file" in',
    '              src/index.ts|src/cli.ts|package.json|tsconfig.json|tsup.config.ts|vitest.config.ts|eslint.config.js)',
    '                TIER=3 ;;',
    '              src/commands/*.ts|src/core/*.ts|src/harnesses/index.ts|src/harnesses/types.ts)',
    '                [[ $TIER -lt 3 ]] && TIER=3 ;;',
    '              src/*.ts|tests/*.ts|scripts/*.ts|*.ts|*.js|*.mjs)',
    '                [[ $TIER -lt 2 ]] && TIER=2 ;;',
    '            esac',
    '          done <<< "$CHANGED"',
    '',
    '          echo "tier=${TIER}" >> "$GITHUB_OUTPUT"',
    '',
    '          # Serialize changed files for the review prompt',
    '          {',
    '            echo "changed-files<<CEOF"',
    '            echo "$CHANGED"',
    '            echo "CEOF"',
    '          } >> "$GITHUB_OUTPUT"',
    '',
    '          echo "‚úî Tier ${TIER} ‚Äî $(echo "$CHANGED" | wc -l) files changed"',
    '',
    '      - name: Skip if Tier 1',
    "        if: steps.tier.outputs.tier == '1'",
    '        run: echo "Tier 1 change ‚Äî review agent not required. Skipping."',
    '',
    '      - name: Notify PR ‚Äî review agent skipped (Tier 1)',
    "        if: steps.tier.outputs.tier == '1'",
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}',
    '          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}',
    '        with:',
    '          script: |',
    '            const headSha = process.env.HEAD_SHA;',
    '            const prNumber = parseInt(process.env.PR_NUMBER, 10);',
    '            const marker = `<!-- harness-tier1-skip: ${headSha} -->`;',
    '',
    '            // Deduplicate: only post once per SHA',
    '            const { data: comments } = await github.rest.issues.listComments({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    '              per_page: 100,',
    '            });',
    '',
    '            if (comments.some((c) => c.body?.includes(marker))) {',
    '              core.info(`Tier 1 skip notification already posted for SHA ${headSha.slice(0, 12)} ‚Äî skipping.`);',
    '              return;',
    '            }',
    '',
    '            await github.rest.issues.createComment({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    '              body: [',
    '                marker,',
    '                `## ‚ÑπÔ∏è Review Agent ‚Äî Skipped (Tier 1)`,',
    "                '',",
    '                `**Commit**: \\`${headSha.slice(0, 12)}\\``,',
    '                `**Tier**: 1 (low risk ‚Äî documentation / non-code changes)`,',
    "                '',",
    "                'This pull request only touches **Tier 1** files (documentation, configuration cosmetics, non-code assets). The automated code review agent does not run for Tier 1 changes ‚Äî they are considered low-risk and only require lint checks.',",
    "                '',",
    "                'If this PR should be reviewed, you can manually trigger the review workflow from the **Actions** tab.',",
    "                '',",
    "                '---',",
    "                '*ü§ñ [Code Review Agent](https://github.com/codefactory) ‚Äî automated code review.*',",
    "              ].join('\\n'),",
    '            });',
    '',
    '            core.info(`Posted Tier 1 skip notification for SHA ${headSha.slice(0, 12)}.`);',
    '',
    '      - name: SHA deduplication check',
    "        if: steps.tier.outputs.tier != '1'",
    '        id: dedup',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}',
    '          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}',
    '        with:',
    '          script: |',
    '            const headSha = process.env.HEAD_SHA;',
    '            const marker = `<!-- harness-review: ${headSha} -->`;',
    '            const prNumber = parseInt(process.env.PR_NUMBER, 10);',
    '',
    '            core.info(`Checking for existing review of SHA ${headSha.slice(0, 12)}...`);',
    '',
    '            const { data: comments } = await github.rest.issues.listComments({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    '              per_page: 100,',
    '            });',
    '',
    '            const alreadyReviewed = comments.some((c) => c.body?.includes(marker));',
    '            if (alreadyReviewed) {',
    '              core.info(`SHA ${headSha.slice(0, 12)} already reviewed ‚Äî skipping.`);',
    "              core.setOutput('skip', 'true');",
    '            } else {',
    '              core.info(`No existing review for SHA ${headSha.slice(0, 12)} ‚Äî proceeding.`);',
    "              core.setOutput('skip', 'false');",
    '            }',
    '',
    '      - name: Create in-progress check run',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'",
    '        id: check',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}',
    '        with:',
    '          script: |',
    '            const headSha = process.env.HEAD_SHA;',
    '            const { data: checkRun } = await github.rest.checks.create({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    "              name: 'review-agent',",
    '              head_sha: headSha,',
    "              status: 'in_progress',",
    '              started_at: new Date().toISOString(),',
    '              output: {',
    "                title: 'Code Review Agent',",
    "                summary: 'Review in progress...',",
    '              },',
    '            });',
    "            core.setOutput('check-run-id', checkRun.id);",
    '            core.info(`Created check run ${checkRun.id} for SHA ${headSha.slice(0, 12)}`);',
    '',
    '      - name: Read review prompt',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'",
    '        id: prompt-file',
    '        run: |',
    '          # Read from origin/main ‚Äî not from the PR branch ‚Äî so the prompt',
    "          # stays up-to-date even for PRs that don't include prompt changes.",
    '          PROMPT_CONTENT=$(git show origin/main:scripts/review-prompt.md 2>/dev/null || echo "")',
    '          if [[ -n "$PROMPT_CONTENT" ]]; then',
    '            {',
    '              echo "content<<PROMPT_EOF"',
    '              echo "$PROMPT_CONTENT"',
    '              echo "PROMPT_EOF"',
    '            } >> "$GITHUB_OUTPUT"',
    '          else',
    '            echo "content=Review this pull request for bugs, security issues, and architectural violations." >> "$GITHUB_OUTPUT"',
    '          fi',
    '',
    '      - name: Build review prompt',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'",
    '        id: build-prompt',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          REVIEW_TEMPLATE: ${{ steps.prompt-file.outputs.content }}',
    '          TIER: ${{ steps.tier.outputs.tier }}',
    '          CHANGED_FILES: ${{ steps.tier.outputs.changed-files }}',
    '        with:',
    '          script: |',
    "            const fs = require('fs');",
    "            const template = process.env.REVIEW_TEMPLATE || '';",
    "            const tier = process.env.TIER || '2';",
    "            const changedFiles = process.env.CHANGED_FILES || '';",
    '',
    "            let conventions = '';",
    "            try { conventions = fs.readFileSync('CLAUDE.md', 'utf-8').slice(0, 6000); } catch {}",
    '',
    "            let config = '';",
    "            try { config = fs.readFileSync('harness.config.json', 'utf-8'); } catch {}",
    '',
    '            const sections = [',
    '              template,',
    "              '',",
    "              '## PR Context',",
    "              '',",
    '              `**Risk Tier**: Tier ${tier}`,',
    '              `**Changed Files**:`,',
    "              changedFiles ? changedFiles.split('\\n').map(f => `- ${f}`).join('\\n') : '*(none detected)*',",
    "              '',",
    "              '## Project Conventions (from CLAUDE.md)',",
    "              '',",
    "              conventions || 'No CLAUDE.md found.',",
    "              '',",
    "              '## Harness Configuration',",
    "              '',",
    "              '```json',",
    "              config || '{}',",
    "              '```',",
    '            ];',
    '',
    "            const prompt = sections.join('\\n');",
    "            core.setOutput('prompt', prompt);",
    '            core.info(`Review prompt built (${prompt.length} chars)`);',
    '',
    '      - name: Run Claude review',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'",
    '        id: review',
    '        # OIDC validation requires the workflow file to match main exactly.',
    '        # PRs that modify this workflow file will always fail the OIDC exchange ‚Äî',
    '        # that is expected and correct (prevents permission escalation). We use',
    '        # continue-on-error so the job still completes and the check run is marked',
    '        # neutral rather than hard-failing the PR.',
    '        continue-on-error: true',
    '        uses: anthropics/claude-code-action@v1',
    '        with:',
    '          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}',
    '          prompt: ${{ steps.build-prompt.outputs.prompt }}',
    '          claude_args: \'--max-turns 100 --allowedTools "Read,Glob,Grep,Bash"\'',
    "          allowed_bots: 'github-actions,implementer-bot'",
    '',
    '      - name: Extract review from execution file',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'",
    '        id: extract',
    '        env:',
    '          EXECUTION_FILE: ${{ steps.review.outputs.execution_file }}',
    '        run: |',
    '          if [[ -z "$EXECUTION_FILE" || ! -f "$EXECUTION_FILE" ]]; then',
    '            echo "found=false" >> "$GITHUB_OUTPUT"',
    '            echo "::warning::No execution file available"',
    '            exit 0',
    '          fi',
    '',
    '          echo "Execution file: ${EXECUTION_FILE} ($(wc -c < "$EXECUTION_FILE") bytes)"',
    '',
    '          # The execution file is a JSON array (not JSONL) from Claude Code SDK.',
    '          # It contains a "result" turn at the end with the final response text.',
    '          # Fallback: extract last assistant text content from message turns.',
    "          REVIEW_TEXT=$(jq -r '",
    '            [.[] | select(.type == "result")] | last | .result // ""',
    '          \' "$EXECUTION_FILE" 2>/dev/null || echo "")',
    '',
    '          # Fallback: if result turn is empty, get last assistant text',
    '          if [[ -z "$REVIEW_TEXT" || "$REVIEW_TEXT" == "null" ]]; then',
    "            REVIEW_TEXT=$(jq -r '",
    '              [.[] | select(.type == "assistant") |',
    '               .message.content[] | select(.type == "text") | .text',
    '              ] | last // ""',
    '            \' "$EXECUTION_FILE" 2>/dev/null || echo "")',
    '          fi',
    '',
    '          if [[ -z "$REVIEW_TEXT" || "$REVIEW_TEXT" == "null" ]]; then',
    '            echo "found=false" >> "$GITHUB_OUTPUT"',
    '            echo "::warning::Could not extract review text from execution file"',
    '          else',
    '            # Truncate to 60000 chars to stay within GitHub comment limits',
    '            REVIEW_TEXT="${REVIEW_TEXT:0:60000}"',
    '            {',
    '              echo "review<<REVIEW_EOF"',
    '              echo "$REVIEW_TEXT"',
    '              echo "REVIEW_EOF"',
    '            } >> "$GITHUB_OUTPUT"',
    '            echo "found=true" >> "$GITHUB_OUTPUT"',
    '            echo "‚úî Extracted review ($(echo "$REVIEW_TEXT" | wc -c) chars)"',
    '          fi',
    '',
    '      - name: Post review comment',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'",
    '        id: post-review',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    "          REVIEW_TEXT: ${{ steps.extract.outputs.review || '' }}",
    "          REVIEW_FOUND: ${{ steps.extract.outputs.found || 'false' }}",
    '          REVIEW_OUTCOME: ${{ steps.review.outcome }}',
    '          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}',
    '          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}',
    '        with:',
    '          script: |',
    '            const headSha = process.env.HEAD_SHA;',
    '            const prNumber = parseInt(process.env.PR_NUMBER, 10);',
    '            const marker = `<!-- harness-review: ${headSha} -->`;',
    "            const tier = '${{ steps.tier.outputs.tier }}';",
    "            const reviewText = process.env.REVIEW_TEXT || '';",
    "            const reviewFound = process.env.REVIEW_FOUND === 'true';",
    "            const reviewOutcome = process.env.REVIEW_OUTCOME || 'failure';",
    '',
    '            const sections = [',
    '              marker,',
    '              `## üîç Code Review Agent ‚Äî Tier ${tier}`,',
    "              '',",
    '              `**Commit**: \\`${headSha.slice(0, 12)}\\``,',
    "              `**Status**: ${reviewOutcome === 'success' ? '‚úÖ Complete' : '‚ö†Ô∏è Review may be incomplete'}`,",
    '            ];',
    '',
    '            if (reviewFound && reviewText) {',
    "              sections.push('', reviewText);",
    '            } else {',
    "              sections.push('', '*No review output was produced. The review agent may have encountered an error.*');",
    '            }',
    '',
    '            sections.push(',
    "              '',",
    "              '---',",
    "              '*ü§ñ [Code Review Agent](https://github.com/codefactory) ‚Äî automated code review.*',",
    '            );',
    '',
    '            const { data: comment } = await github.rest.issues.createComment({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    "              body: sections.join('\\n'),",
    '            });',
    "            core.setOutput('comment-id', comment.id);",
    '',
    '      - name: Run verdict classifier',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true' && steps.extract.outputs.found == 'true'",
    '        id: classifier',
    '        continue-on-error: true',
    '        uses: anthropics/claude-code-action@v1',
    '        with:',
    '          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}',
    '          prompt: |',
    '            Read the following code review and classify the verdict.',
    '',
    '            Rules:',
    '            - APPROVE: The review found no blocking issues. The code is safe to merge.',
    '            - REQUEST_CHANGES: The review found one or more blocking issues (security vulnerabilities, bugs that cause runtime errors, data loss, or crashes). Only blocking issues warrant REQUEST_CHANGES ‚Äî warnings and suggestions do not.',
    '            - COMMENT: The review found warnings or suggestions but no blocking issues, OR the review is unclear.',
    '',
    '            <review>',
    '            ${{ steps.extract.outputs.review }}',
    '            </review>',
    '          claude_args: >-',
    '            --model claude-haiku-4-5-20251001',
    '            --max-turns 3',
    '            --json-schema \'{"type":"object","properties":{"verdict":{"type":"string","enum":["APPROVE","REQUEST_CHANGES","COMMENT"]},"reason":{"type":"string","description":"One sentence explaining the verdict"}},"required":["verdict","reason"]}\'',
    "          allowed_bots: 'github-actions,implementer-bot'",
    '',
    '      - name: Extract verdict',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'",
    '        id: verdict',
    '        env:',
    "          STRUCTURED_OUTPUT: ${{ steps.classifier.outputs.structured_output || '' }}",
    "          EXECUTION_FILE: ${{ steps.classifier.outputs.execution_file || '' }}",
    "          CLASSIFIER_OUTCOME: ${{ steps.classifier.outcome || 'failure' }}",
    '        run: |',
    '          VERDICT="COMMENT"',
    '',
    '          if [[ "$CLASSIFIER_OUTCOME" != "success" ]]; then',
    '            echo "::notice::Verdict classifier failed ‚Äî defaulting to COMMENT."',
    '            echo "verdict=COMMENT" >> "$GITHUB_OUTPUT"',
    '            echo "reason=Classifier failed" >> "$GITHUB_OUTPUT"',
    '            exit 0',
    '          fi',
    '',
    '          # Try structured_output first (from --json)',
    '          if [[ -n "$STRUCTURED_OUTPUT" ]]; then',
    '            VERDICT=$(echo "$STRUCTURED_OUTPUT" | jq -r \'.verdict // empty\' 2>/dev/null || echo "")',
    '            REASON=$(echo "$STRUCTURED_OUTPUT" | jq -r \'.reason // empty\' 2>/dev/null || echo "")',
    '          fi',
    '',
    '          # Fallback: parse execution file result turn',
    '          if [[ -z "$VERDICT" && -n "$EXECUTION_FILE" && -f "$EXECUTION_FILE" ]]; then',
    '            RESULT_TEXT=$(jq -r \'[.[] | select(.type == "result")] | last | .result // ""\' "$EXECUTION_FILE" 2>/dev/null || echo "")',
    '            if [[ -n "$RESULT_TEXT" && "$RESULT_TEXT" != "null" ]]; then',
    '              VERDICT=$(echo "$RESULT_TEXT" | jq -r \'.verdict // empty\' 2>/dev/null || echo "")',
    '              REASON=$(echo "$RESULT_TEXT" | jq -r \'.reason // empty\' 2>/dev/null || echo "")',
    '            fi',
    '          fi',
    '',
    '          # Default to COMMENT if extraction failed (safe ‚Äî no automated action)',
    '          if [[ -z "$VERDICT" || "$VERDICT" == "null" ]]; then',
    '            VERDICT="COMMENT"',
    '            REASON="Could not extract verdict"',
    '            echo "::notice::Could not extract verdict from classifier ‚Äî defaulting to COMMENT."',
    '          fi',
    '',
    '          echo "verdict=${VERDICT}" >> "$GITHUB_OUTPUT"',
    '          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"',
    '          echo "Verdict: ${VERDICT} ‚Äî ${REASON}"',
    '',
    '      - name: Update review comment with verdict',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true' && steps.post-review.outputs.comment-id",
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          COMMENT_ID: ${{ steps.post-review.outputs.comment-id }}',
    "          VERDICT: ${{ steps.verdict.outputs.verdict || 'COMMENT' }}",
    "          VERDICT_REASON: ${{ steps.verdict.outputs.reason || '' }}",
    '        with:',
    '          script: |',
    '            const commentId = parseInt(process.env.COMMENT_ID);',
    "            const verdict = process.env.VERDICT || 'COMMENT';",
    "            const reason = process.env.VERDICT_REASON || '';",
    '            const verdictMarker = `<!-- review-verdict: ${verdict} -->`;',
    "            const verdictEmoji = verdict === 'APPROVE' ? '‚úÖ' : verdict === 'REQUEST_CHANGES' ? 'üîÑ' : 'üí¨';",
    '',
    '            // Fetch current comment body',
    '            const { data: comment } = await github.rest.issues.getComment({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              comment_id: commentId,',
    '            });',
    '',
    '            // Insert verdict marker and badge after the SHA marker line',
    "            let body = comment.body || '';",
    "            const lines = body.split('\\n');",
    "            const insertIdx = lines.findIndex(l => l.startsWith('<!-- harness-review:'));",
    '            if (insertIdx !== -1) {',
    '              lines.splice(insertIdx + 1, 0, verdictMarker);',
    '            } else {',
    '              lines.unshift(verdictMarker);',
    '            }',
    '',
    '            // Insert verdict line after the **Status** line',
    "            const statusIdx = lines.findIndex(l => l.startsWith('**Status**'));",
    '            if (statusIdx !== -1) {',
    "              const verdictLine = `**Verdict**: ${verdictEmoji} ${verdict}${reason ? ` ‚Äî ${reason}` : ''}`;",
    '              lines.splice(statusIdx + 1, 0, verdictLine);',
    '            }',
    '',
    '            await github.rest.issues.updateComment({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              comment_id: commentId,',
    "              body: lines.join('\\n'),",
    '            });',
    '',
    '            core.info(`Updated review comment with verdict: ${verdict}`);',
    '',
    '      - name: Complete check run',
    '        if: always() && steps.check.outputs.check-run-id',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          CHECK_RUN_ID: ${{ steps.check.outputs.check-run-id }}',
    '          REVIEW_OUTCOME: ${{ steps.review.outcome }}',
    '        with:',
    '          script: |',
    '            const checkRunId = parseInt(process.env.CHECK_RUN_ID);',
    "            const reviewOutcome = process.env.REVIEW_OUTCOME || 'failure';",
    "            const conclusion = reviewOutcome === 'success' ? 'success' : 'neutral';",
    '',
    '            await github.rest.checks.update({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              check_run_id: checkRunId,',
    "              status: 'completed',",
    '              conclusion,',
    '              completed_at: new Date().toISOString(),',
    '              output: {',
    "                title: `Review Agent ‚Äî ${conclusion === 'success' ? 'Complete' : 'Review Needed'}`,",
    '                summary: `Claude Code review completed with outcome: ${reviewOutcome}`,',
    '              },',
    '            });',
    '',
    '            core.info(`Check run ${checkRunId} completed: ${conclusion}`);',
    '',
    '      - name: Check review-fix eligibility',
    "        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true' && steps.verdict.outputs.verdict == 'REQUEST_CHANGES'",
    '        id: review-fix',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}',
    '        with:',
    '          script: |',
    '            const prNumber = parseInt(process.env.PR_NUMBER, 10);',
    '',
    '            // Fetch fresh PR data (works for both pull_request and workflow_dispatch triggers)',
    '            const { data: pr } = await github.rest.pulls.get({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              pull_number: prNumber,',
    '            });',
    '            const prLabels = pr.labels.map(l => l.name);',
    '',
    '            // Only auto-fix agent-created PRs',
    "            if (!prLabels.includes('agent-pr')) {",
    "              core.info('PR does not have agent-pr label ‚Äî skipping review-fix dispatch.');",
    "              core.setOutput('eligible', 'false');",
    "              core.setOutput('reason', 'Not an agent-created PR');",
    '              return;',
    '            }',
    '',
    '            // Skip if already escalated',
    "            if (prLabels.includes('agent:needs-judgment')) {",
    "              core.info('PR already has agent:needs-judgment label ‚Äî skipping.');",
    "              core.setOutput('eligible', 'false');",
    "              core.setOutput('reason', 'Already escalated');",
    '              return;',
    '            }',
    '',
    '            // Count review-fix-cycle-N labels to determine cycle number',
    '            let maxCycle = 0;',
    '            for (const label of prLabels) {',
    '              const match = label.match(/^review-fix-cycle-(\\d+)$/);',
    '              if (match) {',
    '                const n = parseInt(match[1], 10);',
    '                if (n > maxCycle) maxCycle = n;',
    '              }',
    '            }',
    '            const nextCycle = maxCycle + 1;',
    '',
    '            if (nextCycle > 3) {',
    '              core.info(`Max review-fix cycles reached (${maxCycle} cycles). Escalating.`);',
    "              core.setOutput('eligible', 'false');",
    "              core.setOutput('escalate', 'true');",
    "              core.setOutput('reason', `Max cycles exceeded (${maxCycle})`);",
    '              return;',
    '            }',
    '',
    '            // Extract linked issue number from PR body marker',
    "            const prBody = pr.body || '';",
    '            const issueMatch = prBody.match(/<!-- issue-implementer: #(\\d+) -->/);',
    "            const issueNumber = issueMatch ? issueMatch[1] : '';",
    '',
    "            core.setOutput('eligible', 'true');",
    "            core.setOutput('escalate', 'false');",
    "            core.setOutput('cycle', String(nextCycle));",
    "            core.setOutput('issue-number', issueNumber);",
    "            core.info(`Review-fix eligible: cycle ${nextCycle}, issue #${issueNumber || 'unknown'}`);",
    '',
    '      - name: Escalate ‚Äî max review-fix cycles',
    "        if: steps.review-fix.outputs.escalate == 'true'",
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}',
    '        with:',
    '          script: |',
    '            const prNumber = parseInt(process.env.PR_NUMBER, 10);',
    '',
    "            // Create label if it doesn't exist",
    '            try {',
    '              await github.rest.issues.createLabel({',
    '                owner: context.repo.owner,',
    '                repo: context.repo.repo,',
    "                name: 'agent:needs-judgment',",
    "                color: 'E4E669',",
    "                description: 'Agent needs human judgment to proceed',",
    '              });',
    '            } catch {}',
    '',
    '            await github.rest.issues.addLabels({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    "              labels: ['agent:needs-judgment'],",
    '            });',
    '',
    '            await github.rest.issues.createComment({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    '              body: [',
    "                '## ‚ö†Ô∏è Review-Fix Loop ‚Äî Max Cycles Reached',",
    "                '',",
    "                'The automated review-fix cycle has reached the maximum of 3 attempts.',",
    "                'A human should review the remaining issues and decide next steps.',",
    "                '',",
    '                `**Run**: [${context.runId}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,',
    "                '',",
    "                '---',",
    "                '*ü§ñ [Code Review Agent](https://github.com/codefactory) ‚Äî automated code review.*',",
    "              ].join('\\n'),",
    '            });',
    '',
    '      - name: Dispatch implementer for review-fix',
    "        if: steps.review-fix.outputs.eligible == 'true'",
    '        env:',
    '          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}',
    '          PR_NUM: ${{ steps.pr.outputs.pr-number }}',
    '          CYCLE: ${{ steps.review-fix.outputs.cycle }}',
    '        run: |',
    '          echo "Dispatching implementer for review-fix: PR #${PR_NUM}, cycle ${CYCLE}"',
    '          gh workflow run issue-implementer.yml \\',
    '            --repo "${{ github.repository }}" \\',
    '            --field pr_number="${PR_NUM}" \\',
    '            --field review_fix_cycle="${CYCLE}"',
    '          echo "‚úî Dispatched issue-implementer.yml for review-fix"',
    '',
    '      - name: Report skip as success',
    "        if: steps.tier.outputs.tier == '1' || steps.dedup.outputs.skip == 'true'",
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}',
    '        with:',
    '          script: |',
    '            const headSha = process.env.HEAD_SHA;',
    "            const tier = '${{ steps.tier.outputs.tier }}';",
    "            const skipped = '${{ steps.dedup.outputs.skip }}' === 'true';",
    "            const reason = tier === '1' ? 'Tier 1 ‚Äî review not required' : `SHA ${headSha.slice(0, 12)} already reviewed`;",
    '',
    '            await github.rest.checks.create({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    "              name: 'review-agent',",
    '              head_sha: headSha,',
    "              status: 'completed',",
    "              conclusion: 'success',",
    '              completed_at: new Date().toISOString(),',
    '              output: {',
    '                title: `Review Agent ‚Äî Skipped`,',
    '                summary: reason,',
    '              },',
    '            });',
    '',
    '            core.info(`Review skipped: ${reason}`);',
  ];
  return lines.join('\n') + '\n';
}

function buildRerunWorkflow(): string {
  const lines = [
    'name: Review Agent Rerun Writer',
    '',
    'on:',
    '  pull_request:',
    '    types: [synchronize]',
    '',
    'permissions:',
    '  contents: read',
    '  pull-requests: write',
    '',
    'concurrency:',
    '  group: review-rerun-${{ github.event.pull_request.number }}',
    '  cancel-in-progress: true',
    '',
    'jobs:',
    '  rerun-writer:',
    '    name: SHA-Deduped Rerun Request',
    '    runs-on: ubuntu-latest',
    '    timeout-minutes: 5',
    '    steps:',
    '      - name: Post rerun comment (SHA-deduped)',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        with:',
    '          script: |',
    '            const headSha = context.payload.pull_request.head.sha;',
    '            const prNumber = context.payload.pull_request.number;',
    '            const owner = context.repo.owner;',
    '            const repo = context.repo.repo;',
    '',
    "            const marker = '<!-- review-agent-auto-rerun -->';",
    '            const trigger = `sha:${headSha}`;',
    '',
    '            core.info(`Checking for existing rerun request for SHA ${headSha.slice(0, 12)}...`);',
    '',
    '            // Fetch existing PR comments (paginate to be safe)',
    '            const comments = await github.paginate(',
    '              github.rest.issues.listComments,',
    '              { owner, repo, issue_number: prNumber, per_page: 100 },',
    '            );',
    '',
    '            // Check if we already requested a rerun for this exact SHA',
    '            const alreadyRequested = comments.some(',
    '              (c) => c.body?.includes(marker) && c.body?.includes(trigger),',
    '            );',
    '',
    '            if (alreadyRequested) {',
    '              core.info(`Rerun already requested for SHA ${headSha.slice(0, 12)} ‚Äî skipping.`);',
    '              return;',
    '            }',
    '',
    '            // Post exactly ONE rerun comment for this SHA',
    '            const body = [',
    '              marker,',
    '              `üîÑ New commits pushed ‚Äî requesting re-review.`,',
    "              '',",
    '              `**Commit**: \\`${headSha.slice(0, 12)}\\``,',
    '              trigger,',
    "            ].join('\\n');",
    '',
    '            await github.rest.issues.createComment({',
    '              owner,',
    '              repo,',
    '              issue_number: prNumber,',
    '              body,',
    '            });',
    '',
    '            core.info(`Posted rerun request for SHA ${headSha.slice(0, 12)}.`);',
  ];
  return lines.join('\n') + '\n';
}

function buildAutoResolveWorkflow(): string {
  const lines = [
    'name: Auto-Resolve Bot Threads',
    '',
    'on:',
    '  check_run:',
    '    types: [completed]',
    '',
    'permissions:',
    '  contents: read',
    '  pull-requests: write',
    '',
    'jobs:',
    '  auto-resolve:',
    '    name: Resolve Stale Bot Threads',
    '    runs-on: ubuntu-latest',
    '    timeout-minutes: 5',
    '    if: >-',
    "      github.event.check_run.name == 'review-agent' &&",
    "      github.event.check_run.conclusion == 'success'",
    '    steps:',
    '      - name: Checkout at reviewed SHA',
    '        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2',
    '        with:',
    '          ref: ${{ github.event.check_run.head_sha }}',
    '',
    '      - name: Resolve bot-only threads',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        with:',
    '          script: |',
    '            const owner = context.repo.owner;',
    '            const repo = context.repo.repo;',
    '            const headSha = context.payload.check_run.head_sha;',
    '',
    '            // Find the PR associated with this check run',
    '            const prs = context.payload.check_run.pull_requests || [];',
    '            if (prs.length === 0) {',
    "              core.info('No PRs associated with this check run ‚Äî nothing to resolve.');",
    '              return;',
    '            }',
    '',
    '            const prNumber = prs[0].number;',
    '            core.info(`Processing PR #${prNumber} at SHA ${headSha.slice(0, 12)}`);',
    '',
    '            // Bot login patterns for the review agent',
    "            const BOT_LOGINS = ['github-actions[bot]', 'github-actions', 'dependabot[bot]'];",
    "            const isBot = (login) => BOT_LOGINS.includes(login) || login.endsWith('[bot]');",
    '',
    '            // Verify this check run is for the current HEAD SHA',
    '            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });',
    '            if (pr.head.sha !== headSha) {',
    '              core.info(`Check run SHA (${headSha.slice(0, 12)}) ‚â† PR HEAD (${pr.head.sha.slice(0, 12)}) ‚Äî stale result, skipping.`);',
    '              return;',
    '            }',
    '',
    '            // Fetch all reviews to find review threads',
    '            const { data: reviews } = await github.rest.pulls.listReviews({',
    '              owner, repo, pull_number: prNumber, per_page: 100,',
    '            });',
    '',
    '            // Fetch all review comments (inline thread comments)',
    '            const reviewComments = await github.paginate(',
    '              github.rest.pulls.listReviewComments,',
    '              { owner, repo, pull_number: prNumber, per_page: 100 },',
    '            );',
    '',
    '            // Group comments by their thread (in_reply_to_id or own id)',
    '            const threads = new Map();',
    '            for (const comment of reviewComments) {',
    '              const threadId = comment.in_reply_to_id || comment.id;',
    '              if (!threads.has(threadId)) {',
    '                threads.set(threadId, []);',
    '              }',
    '              threads.get(threadId).push(comment);',
    '            }',
    '',
    '            let resolvedCount = 0;',
    '',
    '            for (const [threadId, comments] of threads) {',
    '              // Check if all comments in this thread are from bots',
    "              const allBot = comments.every((c) => isBot(c.user?.login || ''));",
    '              if (!allBot) {',
    '                core.info(`Thread ${threadId}: has human comments ‚Äî preserving.`);',
    '                continue;',
    '              }',
    '',
    '              // Check if any comment in the thread is unresolved',
    "              // (GitHub doesn't expose resolved state via REST ‚Äî use GraphQL)",
    '              // For REST API, we minimize threads by hiding outdated bot comments',
    '              const rootComment = comments.find((c) => !c.in_reply_to_id) || comments[0];',
    '',
    '              // Only resolve if the thread is from a prior review (not current SHA)',
    "              // This ensures we don't resolve threads just posted",
    '              const commentSha = rootComment.original_commit_id || rootComment.commit_id;',
    '              if (commentSha === headSha) {',
    '                core.info(`Thread ${threadId}: from current SHA ‚Äî skipping (too new).`);',
    '                continue;',
    '              }',
    '',
    "              // Minimize the root comment to indicate it's been addressed",
    '              try {',
    '                // Use GraphQL to minimize/resolve the comment',
    '                await github.graphql(`',
    '                  mutation($id: ID!) {',
    '                    minimizeComment(input: { subjectId: $id, classifier: RESOLVED }) {',
    '                      minimizedComment { isMinimized }',
    '                    }',
    '                  }',
    '                `, { id: rootComment.node_id });',
    '',
    '                resolvedCount++;',
    '                core.info(`Thread ${threadId}: auto-resolved (bot-only, addressed in ${headSha.slice(0, 12)}).`);',
    '              } catch (error) {',
    '                core.warning(`Failed to resolve thread ${threadId}: ${error.message}`);',
    '              }',
    '            }',
    '',
    '            if (resolvedCount > 0) {',
    '              // Post a summary comment',
    '              await github.rest.issues.createComment({',
    '                owner, repo, issue_number: prNumber,',
    '                body: [',
    '                  `<!-- harness-auto-resolve: ${headSha} -->`,',
    "                  `üßπ Auto-resolved **${resolvedCount}** bot-only review thread${resolvedCount === 1 ? '' : 's'} addressed in commit \\`${headSha.slice(0, 12)}\\`.`,",
    "                  '',",
    "                  '_Threads with human comments are preserved. Only bot-originated threads from prior commits were resolved._',",
    "                ].join('\\n'),",
    '              });',
    '',
    '              core.info(`Auto-resolved ${resolvedCount} bot threads.`);',
    '            } else {',
    "              core.info('No bot-only threads to resolve.');",
    '            }',
  ];
  return lines.join('\n') + '\n';
}

function buildReviewAgentUtils(): string {
  const lines = [
    '#!/usr/bin/env npx tsx',
    '// ============================================================================',
    '// Review Agent Utilities ‚Äî shared helpers for review agent workflows',
    '//',
    '// Provides functions for:',
    '//   - Bot comment detection',
    '//   - Thread analysis (bot-only vs human-participated)',
    '//   - Check run lookup by SHA',
    '//   - HEAD SHA extraction from CI environment',
    '//',
    '// Usage: import directly in scripts, or run standalone for smoke test:',
    '//   npx tsx scripts/review-agent-utils.ts --self-test',
    '//',
    '// Environment variables (set by CI):',
    '//   GITHUB_REPOSITORY  ‚Äî owner/repo',
    '//   GITHUB_SHA         ‚Äî commit SHA (push events)',
    '//   GITHUB_EVENT_PATH  ‚Äî path to event payload JSON',
    '//   GITHUB_TOKEN       ‚Äî auth token for API calls',
    '// ============================================================================',
    '',
    "import { execSync } from 'node:child_process';",
    "import { readFileSync } from 'node:fs';",
    '',
    '// --- Types ---',
    '',
    'export interface Comment {',
    '  id: number;',
    '  node_id?: string;',
    '  user: { login: string };',
    '  body?: string;',
    '  in_reply_to_id?: number;',
    '  commit_id?: string;',
    '  original_commit_id?: string;',
    '}',
    '',
    'export interface CheckRun {',
    '  id: number;',
    '  name: string;',
    '  head_sha: string;',
    "  status: 'queued' | 'in_progress' | 'completed';",
    '  conclusion: string | null;',
    '  started_at: string;',
    '  completed_at: string | null;',
    '  output: {',
    '    title: string | null;',
    '    summary: string | null;',
    '  };',
    '}',
    '',
    '// --- Constants ---',
    '',
    '/** Known bot login patterns for review agent comments. */',
    'const BOT_LOGINS = new Set([',
    "  'github-actions[bot]',",
    "  'github-actions',",
    "  'dependabot[bot]',",
    ']);',
    '',
    '// --- Public API ---',
    '',
    '/**',
    ' * Check if a comment was authored by a known bot account.',
    ' * Returns true for github-actions[bot], dependabot[bot], and any login ending in [bot].',
    ' */',
    'export function isReviewBotComment(comment: { user: { login: string } }): boolean {',
    '  const login = comment.user.login;',
    "  return BOT_LOGINS.has(login) || login.endsWith('[bot]');",
    '}',
    '',
    '/**',
    ' * Check if ALL comments in a thread are from bot accounts.',
    ' * Returns false if any human has participated in the thread.',
    ' * Returns true for empty threads (no comments to contradict).',
    ' */',
    'export function isThreadBotOnly(thread: Comment[]): boolean {',
    '  if (thread.length === 0) return true;',
    '  return thread.every((c) => isReviewBotComment(c));',
    '}',
    '',
    '/**',
    ' * Fetch the latest review-agent check run for a specific SHA.',
    ' * Requires `gh` CLI and GITHUB_REPOSITORY env var.',
    ' * Returns null if no check run is found or on error.',
    ' */',
    'export function getLatestReviewRunForSha(',
    '  owner: string,',
    '  repo: string,',
    '  sha: string,',
    '): CheckRun | null {',
    '  try {',
    '    const output = execSync(',
    '      `gh api "repos/${owner}/${repo}/commits/${sha}/check-runs" --jq \'.check_runs[] | select(.name == "review-agent")\'`,',
    "      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] },",
    '    );',
    '',
    '    if (!output.trim()) return null;',
    '',
    '    // gh --jq returns one JSON object per line; take the last (most recent)',
    "    const lines = output.trim().split('\\n');",
    '    const lastLine = lines[lines.length - 1];',
    '    const parsed = JSON.parse(lastLine) as CheckRun;',
    '',
    '    return parsed;',
    '  } catch {',
    '    return null;',
    '  }',
    '}',
    '',
    '/**',
    ' * Get the current PR head SHA from the CI environment.',
    ' *',
    ' * Resolution order:',
    ' * 1. GITHUB_EVENT_PATH ‚Üí pull_request.head.sha (PR events)',
    ' * 2. GITHUB_SHA (push events, fallback)',
    ' * 3. git rev-parse HEAD (local mode)',
    ' */',
    'export function getHeadSha(): string {',
    '  // Try PR event payload first',
    '  const eventPath = process.env.GITHUB_EVENT_PATH;',
    '  if (eventPath) {',
    '    try {',
    "      const event = JSON.parse(readFileSync(eventPath, 'utf-8'));",
    '      if (event.pull_request?.head?.sha) {',
    '        return event.pull_request.head.sha;',
    '      }',
    '    } catch {',
    '      // Fall through to next method',
    '    }',
    '  }',
    '',
    '  // Try GITHUB_SHA',
    '  if (process.env.GITHUB_SHA) {',
    '    return process.env.GITHUB_SHA;',
    '  }',
    '',
    '  // Fall back to git',
    '  try {',
    "    return execSync('git rev-parse HEAD', {",
    "      encoding: 'utf-8',",
    "      stdio: ['pipe', 'pipe', 'pipe'],",
    '    }).trim();',
    '  } catch {',
    '    throw new Error(',
    "      'Unable to determine HEAD SHA: no GITHUB_EVENT_PATH, GITHUB_SHA, or git repository found.',",
    '    );',
    '  }',
    '}',
    '',
    '/**',
    ' * Check if a given SHA has already been reviewed by searching for the',
    ' * harness review marker in PR comments.',
    ' */',
    'export function hasExistingReview(',
    '  comments: Array<{ body?: string }>,',
    '  sha: string,',
    '): boolean {',
    '  const marker = `<!-- harness-review: ${sha} -->`;',
    '  return comments.some((c) => c.body?.includes(marker));',
    '}',
    '',
    '/**',
    ' * Check if a rerun has already been requested for a given SHA.',
    ' */',
    'export function hasExistingRerunRequest(',
    '  comments: Array<{ body?: string }>,',
    '  sha: string,',
    '): boolean {',
    "  const marker = '<!-- review-agent-auto-rerun -->';",
    '  const trigger = `sha:${sha}`;',
    '  return comments.some((c) => c.body?.includes(marker) && c.body?.includes(trigger));',
    '}',
    '',
    '// --- Self-test (run with --self-test) ---',
    '',
    "if (process.argv.includes('--self-test')) {",
    "  console.log('Running review-agent-utils self-test...\\n');",
    '',
    '  // isReviewBotComment',
    '  console.assert(',
    "    isReviewBotComment({ user: { login: 'github-actions[bot]' } }) === true,",
    "    'github-actions[bot] should be a bot',",
    '  );',
    '  console.assert(',
    "    isReviewBotComment({ user: { login: 'octocat' } }) === false,",
    "    'octocat should not be a bot',",
    '  );',
    '  console.assert(',
    "    isReviewBotComment({ user: { login: 'my-custom[bot]' } }) === true,",
    "    'custom [bot] suffix should be detected',",
    '  );',
    '',
    '  // isThreadBotOnly',
    "  console.assert(isThreadBotOnly([]) === true, 'empty thread is bot-only');",
    '  console.assert(',
    '    isThreadBotOnly([',
    "      { id: 1, user: { login: 'github-actions[bot]' } },",
    "      { id: 2, user: { login: 'dependabot[bot]' }, in_reply_to_id: 1 },",
    '    ]) === true,',
    "    'all-bot thread should be bot-only',",
    '  );',
    '  console.assert(',
    '    isThreadBotOnly([',
    "      { id: 1, user: { login: 'github-actions[bot]' } },",
    "      { id: 2, user: { login: 'developer' }, in_reply_to_id: 1 },",
    '    ]) === false,',
    "    'thread with human should not be bot-only',",
    '  );',
    '',
    '  // hasExistingReview',
    '  console.assert(',
    '    hasExistingReview(',
    "      [{ body: '<!-- harness-review: abc123 -->\\nReview content' }],",
    "      'abc123',",
    '    ) === true,',
    "    'should find existing review',",
    '  );',
    '  console.assert(',
    '    hasExistingReview(',
    "      [{ body: '<!-- harness-review: abc123 -->\\nReview content' }],",
    "      'def456',",
    '    ) === false,',
    "    'should not find review for different SHA',",
    '  );',
    '',
    '  // hasExistingRerunRequest',
    '  console.assert(',
    '    hasExistingRerunRequest(',
    "      [{ body: '<!-- review-agent-auto-rerun -->\\n@review-agent please re-review\\nsha:abc123' }],",
    "      'abc123',",
    '    ) === true,',
    "    'should find existing rerun request',",
    '  );',
    '  console.assert(',
    '    hasExistingRerunRequest(',
    "      [{ body: '<!-- review-agent-auto-rerun -->\\nsha:abc123' }],",
    "      'def456',",
    '    ) === false,',
    "    'should not find rerun for different SHA',",
    '  );',
    '',
    '  // getHeadSha (local mode ‚Äî should fall back to git)',
    '  try {',
    '    const sha = getHeadSha();',
    "    console.assert(sha.length >= 7, 'SHA should be at least 7 chars');",
    '    console.log(`‚úî getHeadSha() returned: ${sha.slice(0, 12)}`);',
    '  } catch (error) {',
    '    const msg = error instanceof Error ? error.message : String(error);',
    '    console.log(`‚ö† getHeadSha() threw (expected outside git repo): ${msg}`);',
    '  }',
    '',
    "  console.log('\\n‚úî All self-tests passed.');",
    '}',
  ];
  return lines.join('\n') + '\n';
}

function buildReviewPrompt(): string {
  return `# Code Review Agent ‚Äî Review Prompt

You are a senior TypeScript engineer performing an automated code review on a pull request. Your review must be thorough, actionable, and focused on substance over style.

## Your Role

- Review the PR diff for correctness, security, and architectural compliance.
- The linter and formatter handle style ‚Äî do not comment on formatting, whitespace, or import order.
- Focus on bugs, security vulnerabilities, data integrity risks, and architectural violations.
- This project uses **relaxed** strictness: only bugs and security issues are blocking. All other findings are informational.

## Severity Classification

Classify every finding into exactly one severity:

### Blocking (must fix before merge)

- Security vulnerabilities (injection, XSS, SSRF, auth bypass, secret exposure)
- Bugs that will cause runtime errors, data loss, or incorrect behavior
- Unhandled error paths that could crash the process
- Shell command injection via unsanitized input (this project spawns \`claude\` as child process)

### Warning (should fix)

- Architectural boundary violations (see boundaries below)
- Missing error handling for async operations
- Missing or inadequate test coverage for changed logic
- Type safety issues: \`any\` usage, unchecked casts, missing null checks
- Missing \`.js\` extensions on local ESM imports (enforced by \`verbatimModuleSyntax\`)

### Suggestion (nice to have)

- Performance improvements
- Cleaner patterns or abstractions
- Better variable naming or documentation
- Opportunities for code reuse

## TypeScript-Specific Checks

- **Type safety**: Flag \`any\` usage, unchecked type assertions (\`as\`), missing null/undefined checks.
- **Error handling**: Every \`catch\` block should handle errors with the pattern \`error instanceof Error ? error.message : String(error)\`. No bare \`catch {}\`.
- **ESM discipline**: Local imports must use \`.js\` extensions. \`import type\` must be separate from value imports (\`verbatimModuleSyntax\`).
- **Async safety**: Verify all Promises are awaited or explicitly handled. No fire-and-forget.
- **Input validation**: External input at system boundaries must be validated with Zod schemas.

## Architectural Boundary Rules

This project enforces strict import boundaries between layers:

| Layer       | Allowed Imports                         |
| ----------- | --------------------------------------- |
| \`utils\`     | (nothing)                               |
| \`ui\`        | \`utils\`                                 |
| \`core\`      | \`utils\`                                 |
| \`commands\`  | \`core\`, \`ui\`, \`utils\`                   |
| \`prompts\`   | \`core\`, \`utils\`                         |
| \`providers\` | \`core\`, \`utils\`                         |
| \`harnesses\` | \`core\`, \`prompts\`, \`providers\`, \`utils\` |

Flag any import that violates these boundaries. Never import from \`commands\` or \`harnesses\` inside \`core\`.

## Review Constraints

- Do NOT suggest changes that contradict the project's CLAUDE.md conventions.
- Do NOT flag issues already caught by eslint or the TypeScript compiler.
- Do NOT comment on test file style ‚Äî test files have more flexibility.
- Keep findings concise: one sentence per issue, with file and line reference.

## Output Format

Write your review in natural markdown. Structure it as follows:

### Summary

One paragraph summarizing the changes and their purpose.

### Risk Assessment

State the confirmed risk tier (Tier 1/2/3) and briefly explain why.

### Issues

If you found issues, list them as a numbered list. For each issue include:

- **Severity** (blocking / warning / suggestion)
- **Location** (\`file:line\`)
- **Description** ‚Äî what is wrong and how to fix it

If no issues were found, say so explicitly.

### Architecture

Note whether the changes comply with the architectural boundary rules. Flag any violations.

### Test Coverage

Briefly assess whether test coverage is adequate for the changes.

## Automated Feedback Loop

Your review will be read by a separate verdict classifier that decides whether to approve, request changes, or leave a comment. If changes are requested, an automated implementer agent will attempt to fix the blocking issues you describe. So for any blocking issue, be precise: include the exact file path, line number, and a clear description of what is wrong and how to fix it. The implementer cannot fix vague feedback like "improve error handling" ‚Äî it needs specific locations and actionable instructions.
`;
}

function buildCodefactoryPrompt(): string {
  return `# Review Agent Instructions

You are a code review agent. Your task is to review a pull request for quality, correctness, and adherence to project conventions.

## Review Checklist

### Code Quality

- Does the code follow the project's style conventions (see CLAUDE.md)?
- Are there any obvious bugs, race conditions, or edge cases?
- Is error handling appropriate and consistent?
- Are there any security concerns (injection, XSS, secrets, etc.)?

### Architecture

- Does the change respect architectural boundaries (see harness.config.json)?
- Are imports following the dependency rules?
- Is the change in the right layer/module?

### Testing

- Are there tests for new functionality?
- Do existing tests still pass?
- Are edge cases covered?

### Scope

- Does the PR do only what it claims to do?
- Are there unrelated changes that should be in a separate PR?
- Is the PR a reasonable size for review?

### Risk Assessment

- Which risk tier does this change fall into (Tier 1/2/3)?
- Does it touch critical paths that need extra scrutiny?
- Are there any breaking changes?

## Output Format

Write your review in natural markdown. Include these sections:

1. **Summary**: One paragraph overview of the changes
2. **Risk Assessment**: Confirmed tier (1/2/3) and brief reasoning
3. **Issues**: Numbered list of specific problems found (with severity, file:line, description). If none found, say so explicitly.
4. **Architecture**: Whether changes comply with boundary rules
5. **Test Coverage**: Brief assessment of test adequacy

Do NOT output JSON. Write a clear, human-readable review.

## Automated Feedback Loop

A separate verdict classifier reads your review and decides APPROVE / REQUEST_CHANGES / COMMENT. If changes are requested, the implementer agent automatically fixes the blocking issues you describe. So for any blocking issue, be precise: include the exact file path, line number, and a clear actionable description. The implementer cannot fix vague feedback.
`;
}
