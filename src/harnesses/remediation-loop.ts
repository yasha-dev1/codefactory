import { join } from 'node:path';

import type { HarnessModule, HarnessContext, HarnessOutput } from './types.js';

export const remediationLoopHarness: HarnessModule = {
  name: 'remediation-loop',
  displayName: 'Remediation Loop',
  description: 'Generates automated remediation agent workflow for fixing review findings',
  order: 8,

  isApplicable(): boolean {
    return true;
  },

  async execute(ctx: HarnessContext): Promise<HarnessOutput> {
    const snap = ctx.fileWriter.snapshot();
    const d = ctx.detection;

    const testCmd = d.testCommand ?? 'npm test';
    const lintCmd = d.lintCommand ?? 'npm run lint';

    // ‚îÄ‚îÄ 1. Remediation agent workflow ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    await ctx.fileWriter.write(
      join(ctx.repoRoot, '.github/workflows/remediation-agent.yml'),
      buildRemediationWorkflow(testCmd, lintCmd),
    );

    // ‚îÄ‚îÄ 2. Remediation agent prompt ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    await ctx.fileWriter.write(
      join(ctx.repoRoot, 'scripts/remediation-agent-prompt.md'),
      buildRemediationPrompt(lintCmd, testCmd),
    );

    // ‚îÄ‚îÄ 3. Remediation guard script ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    await ctx.fileWriter.write(
      join(ctx.repoRoot, 'scripts/remediation-guard.ts'),
      buildRemediationGuard(),
    );

    const diff = ctx.fileWriter.diffSince(snap);

    const output: HarnessOutput = {
      harnessName: 'remediation-loop',
      filesCreated: diff.created,
      filesModified: diff.modified,
      metadata: {
        targetFiles: [
          '.github/workflows/remediation-agent.yml',
          'scripts/remediation-agent-prompt.md',
        ],
      },
    };

    ctx.previousOutputs.set('remediation-loop', output);

    return output;
  },
};

// ‚îÄ‚îÄ File builders ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function buildRemediationWorkflow(testCmd: string, lintCmd: string): string {
  const lines = [
    'name: Remediation Agent',
    '',
    'on:',
    '  workflow_dispatch:',
    '    inputs:',
    '      pr_number:',
    '        description: PR number to remediate',
    '        required: true',
    '        type: number',
    '      head_sha:',
    '        description: Commit SHA to fix against (SHA discipline)',
    '        required: true',
    '        type: string',
    '      findings:',
    '        description: JSON array of actionable review findings',
    '        required: true',
    '        type: string',
    '',
    'permissions:',
    '  contents: write',
    '  pull-requests: write',
    '  id-token: write',
    '',
    'concurrency:',
    '  group: remediation-${{ inputs.pr_number }}',
    '  cancel-in-progress: false',
    '',
    'jobs:',
    '  remediate:',
    '    name: Remediation Agent',
    '    runs-on: ubuntu-latest',
    '    timeout-minutes: 20',
    '    steps:',
    '      - name: Get PR branch info',
    '        id: pr-info',
    '        env:',
    '          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}',
    '        run: |',
    '          PR_JSON=$(gh pr view ${{ inputs.pr_number }} --repo "${{ github.repository }}" --json headRefName,headRefOid,state)',
    '          BRANCH=$(echo "$PR_JSON" | jq -r \'.headRefName\')',
    '          CURRENT_SHA=$(echo "$PR_JSON" | jq -r \'.headRefOid\')',
    '          STATE=$(echo "$PR_JSON" | jq -r \'.state\')',
    '',
    '          if [[ "$STATE" != "OPEN" ]]; then',
    '            echo "::error::PR #${{ inputs.pr_number }} is ${STATE}, not OPEN. Aborting."',
    '            exit 1',
    '          fi',
    '',
    '          echo "branch=${BRANCH}" >> "$GITHUB_OUTPUT"',
    '          echo "current-sha=${CURRENT_SHA}" >> "$GITHUB_OUTPUT"',
    '',
    '      - name: SHA discipline check',
    '        run: |',
    '          CURRENT="${{ steps.pr-info.outputs.current-sha }}"',
    '          EXPECTED="${{ inputs.head_sha }}"',
    '          if [[ "${CURRENT,,}" != "${EXPECTED,,}" ]]; then',
    '            echo "::error::SHA discipline violation: PR HEAD (${CURRENT}) ‚â† expected (${EXPECTED}). Branch was updated since dispatch."',
    '            exit 1',
    '          fi',
    '          echo "‚úî SHA verified: ${CURRENT:0:12}"',
    '',
    '      - name: Checkout PR branch',
    '        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2',
    '        with:',
    '          ref: ${{ steps.pr-info.outputs.branch }}',
    '          fetch-depth: 0',
    '          token: ${{ secrets.GITHUB_TOKEN }}',
    '',
    '      - name: Verify checkout SHA',
    '        run: |',
    '          ACTUAL="$(git rev-parse HEAD)"',
    '          EXPECTED="${{ inputs.head_sha }}"',
    '          if [[ "${ACTUAL,,}" != "${EXPECTED,,}" ]]; then',
    '            echo "::error::Post-checkout SHA mismatch: ${ACTUAL} ‚â† ${EXPECTED}"',
    '            exit 1',
    '          fi',
    '',
    '      - name: Setup Node.js',
    '        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af # v4.1.0',
    '        with:',
    '          node-version: 22',
    '          cache: npm',
    '',
    '      - name: Install dependencies',
    '        run: npm ci',
    '',
    '      - name: Run remediation guard',
    '        id: guard',
    '        env:',
    '          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}',
    '          PR_NUMBER: ${{ inputs.pr_number }}',
    '          FINDINGS: ${{ inputs.findings }}',
    '          STRICTNESS: relaxed',
    '          GITHUB_REPOSITORY: ${{ github.repository }}',
    '        run: |',
    '          DECISION=$(npx tsx scripts/remediation-guard.ts --evaluate)',
    '          echo "decision<<GUARD_EOF" >> "$GITHUB_OUTPUT"',
    '          echo "$DECISION" >> "$GITHUB_OUTPUT"',
    '          echo "GUARD_EOF" >> "$GITHUB_OUTPUT"',
    '',
    '          SHOULD=$(echo "$DECISION" | jq -r \'.shouldRemediate\')',
    '          ATTEMPT=$(echo "$DECISION" | jq -r \'.attemptNumber\')',
    '          REASON=$(echo "$DECISION" | jq -r \'.reason\')',
    '          echo "should-remediate=${SHOULD}" >> "$GITHUB_OUTPUT"',
    '          echo "attempt=${ATTEMPT}" >> "$GITHUB_OUTPUT"',
    '          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"',
    '',
    '          echo "Guard: shouldRemediate=${SHOULD}, attempt=${ATTEMPT}"',
    '',
    '      - name: Post guard rejection comment',
    "        if: steps.guard.outputs.should-remediate == 'false'",
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          DECISION: ${{ steps.guard.outputs.decision }}',
    '        with:',
    '          script: |',
    '            const prNumber = ${{ inputs.pr_number }};',
    "            const headSha = '${{ inputs.head_sha }}';",
    '            const decision = JSON.parse(process.env.DECISION);',
    '            const marker = `<!-- remediation-blocked: ${headSha} -->`;',
    '',
    '            const sections = [',
    '              marker,',
    "              '## üõë Remediation Agent ‚Äî Blocked',",
    "              '',",
    '              `**Reason**: ${decision.reason}`,',
    '              `**Attempt**: ${decision.attemptNumber}`,',
    '              `**SHA**: \\`${headSha.slice(0, 12)}\\``,',
    '            ];',
    '',
    '            if (decision.securityBlockers.length > 0) {',
    "              sections.push('', '### Security Findings (require human review)');",
    '              for (const s of decision.securityBlockers) sections.push(`- ${s}`);',
    '            }',
    '',
    '            if (decision.skippedFindings.length > 0) {',
    "              sections.push('', '### Skipped Findings');",
    '              for (const s of decision.skippedFindings) sections.push(`- ${s}`);',
    '            }',
    '',
    '            sections.push(',
    "              '',",
    "              '---',",
    "              '*ü§ñ [Remediation agent](https://github.com/codefactory) ‚Äî auto-fix blocked.*',",
    '            );',
    '',
    '            await github.rest.issues.createComment({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    "              body: sections.join('\\n'),",
    '            });',
    '',
    '      - name: Build remediation prompt',
    "        if: steps.guard.outputs.should-remediate == 'true'",
    '        id: build-prompt',
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          FINDINGS_JSON: ${{ inputs.findings }}',
    '          HEAD_SHA: ${{ inputs.head_sha }}',
    '        with:',
    '          script: |',
    "            const fs = require('fs');",
    '',
    "            let template = '';",
    "            try { template = fs.readFileSync('scripts/remediation-agent-prompt.md', 'utf-8'); } catch {}",
    '',
    "            let conventions = '';",
    "            try { conventions = fs.readFileSync('CLAUDE.md', 'utf-8').slice(0, 6000); } catch {}",
    '',
    "            let config = '';",
    "            try { config = fs.readFileSync('harness.config.json', 'utf-8'); } catch {}",
    '',
    '            const findings = process.env.FINDINGS_JSON;',
    '            const sha = process.env.HEAD_SHA;',
    '',
    '            const prompt = [',
    '              template,',
    "              '',",
    "              '## Project Conventions (from CLAUDE.md)',",
    "              '',",
    "              conventions || 'No CLAUDE.md found.',",
    "              '',",
    "              '## Harness Configuration',",
    "              '',",
    "              '```json',",
    "              config || '{}',",
    "              '```',",
    "              '',",
    "              '## Findings to Fix',",
    "              '',",
    "              '```json',",
    '              findings,',
    "              '```',",
    "              '',",
    '              `## HEAD SHA: \\`${sha}\\``,',
    "              '',",
    "              'Fix ONLY the findings listed above. Edit each file directly.',",
    "              'After all fixes, output a JSON object:',",
    "              '```json',",
    "              '{',",
    '              \'  "fixed": [{ "file": "path", "finding": "description", "change": "what changed" }],\',',
    '              \'  "skipped": [{ "file": "path", "finding": "description", "reason": "why" }],\',',
    '              \'  "filesModified": ["path1", "path2"]\',',
    "              '}',",
    "              '```',",
    "            ].join('\\n');",
    '',
    "            core.setOutput('prompt', prompt);",
    '            core.info(`Prompt built (${prompt.length} chars)`);',
    '',
    '      - name: Run Claude remediation',
    "        if: steps.guard.outputs.should-remediate == 'true'",
    '        id: claude',
    '        uses: anthropics/claude-code-action@v1',
    '        with:',
    '          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}',
    '          prompt: ${{ steps.build-prompt.outputs.prompt }}',
    "          claude_args: '--max-turns 15'",
    '',
    '      - name: Check for file changes',
    "        if: steps.guard.outputs.should-remediate == 'true'",
    '        id: changes',
    '        run: |',
    '          CHANGED=$(git diff --name-only 2>/dev/null || echo "")',
    '          if [[ -z "$CHANGED" ]]; then',
    '            echo "has-changes=false" >> "$GITHUB_OUTPUT"',
    '            echo "::notice::No files were modified by the remediation agent."',
    '          else',
    '            echo "has-changes=true" >> "$GITHUB_OUTPUT"',
    '            COUNT=$(echo "$CHANGED" | wc -l)',
    '            echo "count=${COUNT}" >> "$GITHUB_OUTPUT"',
    '            {',
    '              echo "files<<FILES_EOF"',
    '              echo "$CHANGED"',
    '              echo "FILES_EOF"',
    '            } >> "$GITHUB_OUTPUT"',
    '            echo "‚úî ${COUNT} file(s) modified"',
    '          fi',
    '',
    '      - name: Verify no protected files modified',
    "        if: steps.changes.outputs.has-changes == 'true'",
    '        id: protected',
    '        run: |',
    '          MODIFIED=$(git diff --name-only)',
    '          VIOLATIONS=""',
    '',
    '          while IFS= read -r file; do',
    '            [[ -z "$file" ]] && continue',
    '            case "$file" in',
    '              .github/workflows/*|harness.config.json|CLAUDE.md|package-lock.json|yarn.lock|pnpm-lock.yaml)',
    '                VIOLATIONS="${VIOLATIONS}  - ${file}\\n"',
    '                git checkout -- "$file"',
    '                echo "::warning::Reverted protected file: ${file}"',
    '                ;;',
    '            esac',
    '          done <<< "$MODIFIED"',
    '',
    '          if [[ -n "$VIOLATIONS" ]]; then',
    '            echo "reverted=true" >> "$GITHUB_OUTPUT"',
    '            echo "::warning::Reverted modifications to protected files."',
    '          else',
    '            echo "reverted=false" >> "$GITHUB_OUTPUT"',
    '          fi',
    '',
    '          # Re-check if we still have changes after reverting',
    '          REMAINING=$(git diff --name-only 2>/dev/null || echo "")',
    '          if [[ -z "$REMAINING" ]]; then',
    '            echo "::notice::No changes remain after reverting protected files."',
    '            echo "has-remaining=false" >> "$GITHUB_OUTPUT"',
    '          else',
    '            echo "has-remaining=true" >> "$GITHUB_OUTPUT"',
    '          fi',
    '',
    '      - name: Run validation ‚Äî Lint',
    "        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'",
    '        id: lint',
    '        run: |',
    '          # Try eslint auto-fix first for minor formatting issues',
    '          npx eslint src/ --fix 2>/dev/null || true',
    '',
    `          if ${lintCmd}; then`,
    '            echo "passed=true" >> "$GITHUB_OUTPUT"',
    '          else',
    '            echo "passed=false" >> "$GITHUB_OUTPUT"',
    '          fi',
    '',
    '      - name: Run validation ‚Äî Type Check',
    "        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'",
    '        id: typecheck',
    '        run: |',
    '          if npm run typecheck; then',
    '            echo "passed=true" >> "$GITHUB_OUTPUT"',
    '          else',
    '            echo "passed=false" >> "$GITHUB_OUTPUT"',
    '          fi',
    '',
    '      - name: Run validation ‚Äî Tests',
    "        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'",
    '        id: test',
    '        run: |',
    `          if ${testCmd}; then`,
    '            echo "passed=true" >> "$GITHUB_OUTPUT"',
    '          else',
    '            echo "passed=false" >> "$GITHUB_OUTPUT"',
    '          fi',
    '',
    '      - name: Evaluate validation results',
    "        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'",
    '        id: validation',
    '        run: |',
    '          LINT="${{ steps.lint.outputs.passed }}"',
    '          TYPECHECK="${{ steps.typecheck.outputs.passed }}"',
    '          TEST="${{ steps.test.outputs.passed }}"',
    '',
    '          echo "lint=${LINT}, typecheck=${TYPECHECK}, test=${TEST}"',
    '',
    '          if [[ "$LINT" == "true" && "$TYPECHECK" == "true" && "$TEST" == "true" ]]; then',
    '            echo "passed=true" >> "$GITHUB_OUTPUT"',
    '          else',
    '            echo "passed=false" >> "$GITHUB_OUTPUT"',
    '            echo "::warning::Validation failed ‚Äî reverting all remediation changes."',
    '            git checkout -- .',
    '          fi',
    '',
    '      - name: Commit and push',
    "        if: steps.validation.outputs.passed == 'true'",
    '        id: commit',
    '        run: |',
    '          git config user.name "remediation-bot[bot]"',
    '          git config user.email "remediation-bot[bot]@users.noreply.github.com"',
    '',
    '          ATTEMPT="${{ steps.guard.outputs.attempt }}"',
    '          MODIFIED=$(git diff --name-only)',
    '',
    '          git add $MODIFIED',
    '',
    '          FILE_COUNT=$(echo "$MODIFIED" | wc -l | tr -d \' \')',
    '',
    '          git commit -m "$(cat <<COMMIT_EOF',
    '          fix: [remediation] auto-fix review finding(s) (attempt ${ATTEMPT})',
    '',
    '          Remediation agent auto-fix for PR #${{ inputs.pr_number }}.',
    '          SHA: ${{ inputs.head_sha }}',
    '',
    '          Files modified: ${FILE_COUNT}',
    "          Files: $(echo \"$MODIFIED\" | tr '\\n' ',')",
    '          COMMIT_EOF',
    '          )"',
    '',
    '          git push',
    '          NEW_SHA=$(git rev-parse HEAD)',
    '          echo "new-sha=${NEW_SHA}" >> "$GITHUB_OUTPUT"',
    '          echo "‚úî Pushed remediation commit: ${NEW_SHA:0:12}"',
    '',
    '      - name: Add remediation attempt label',
    "        if: steps.guard.outputs.should-remediate == 'true'",
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          ATTEMPT: ${{ steps.guard.outputs.attempt }}',
    '        with:',
    '          script: |',
    '            const prNumber = ${{ inputs.pr_number }};',
    '            const attempt = parseInt(process.env.ATTEMPT);',
    '            const label = `remediation-attempt-${attempt}`;',
    '',
    "            // Create label if it doesn't exist",
    '            try {',
    '              await github.rest.issues.createLabel({',
    '                owner: context.repo.owner,',
    '                repo: context.repo.repo,',
    '                name: label,',
    "                color: 'FFA500',",
    '                description: `Remediation agent attempt ${attempt}`,',
    '              });',
    '            } catch {',
    "              // Label already exists ‚Äî that's fine",
    '            }',
    '',
    '            await github.rest.issues.addLabels({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    '              labels: [label],',
    '            });',
    '',
    '            core.info(`Added label: ${label}`);',
    '',
    '      - name: Post audit comment',
    "        if: always() && steps.guard.outputs.should-remediate == 'true'",
    '        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1',
    '        env:',
    '          GUARD_DECISION: ${{ steps.guard.outputs.decision }}',
    '          HAS_CHANGES: ${{ steps.changes.outputs.has-changes }}',
    '          CHANGED_FILES: ${{ steps.changes.outputs.files }}',
    '          VALIDATION_PASSED: ${{ steps.validation.outputs.passed }}',
    '          LINT_PASSED: ${{ steps.lint.outputs.passed }}',
    '          TYPECHECK_PASSED: ${{ steps.typecheck.outputs.passed }}',
    '          TEST_PASSED: ${{ steps.test.outputs.passed }}',
    '          NEW_SHA: ${{ steps.commit.outputs.new-sha }}',
    '          ATTEMPT: ${{ steps.guard.outputs.attempt }}',
    '        with:',
    '          script: |',
    '            const prNumber = ${{ inputs.pr_number }};',
    "            const headSha = '${{ inputs.head_sha }}';",
    '            const attempt = process.env.ATTEMPT;',
    '            const marker = `<!-- remediation-audit: ${headSha} -->`;',
    '',
    "            const hasChanges = process.env.HAS_CHANGES === 'true';",
    "            const validationPassed = process.env.VALIDATION_PASSED === 'true';",
    "            const newSha = process.env.NEW_SHA || '';",
    '',
    "            const lintOk = process.env.LINT_PASSED === 'true';",
    "            const typecheckOk = process.env.TYPECHECK_PASSED === 'true';",
    "            const testOk = process.env.TEST_PASSED === 'true';",
    '',
    "            const statusEmoji = validationPassed && newSha ? '‚úÖ' : hasChanges ? '‚ö†Ô∏è' : 'üí¨';",
    '            const statusText = validationPassed && newSha',
    "              ? 'Fixes Applied'",
    '              : hasChanges',
    "                ? 'Fixes Failed Validation'",
    "                : 'No Changes Made';",
    '',
    "            const changedFiles = (process.env.CHANGED_FILES || '').trim();",
    '            const filesSection = changedFiles ? [',
    "              '### Files Modified',",
    "              '',",
    "              ...changedFiles.split('\\n').map((f) => `- \\`${f}\\``),",
    "            ].join('\\n') : '';",
    '',
    '            const validationSection = hasChanges ? [',
    "              '### Validation',",
    "              '',",
    '              `| Check | Status |`,',
    '              `|-------|--------|`,',
    "              `| Lint | ${lintOk ? '‚úÖ' : '‚ùå'} |`,",
    "              `| Type Check | ${typecheckOk ? '‚úÖ' : '‚ùå'} |`,",
    "              `| Tests | ${testOk ? '‚úÖ' : '‚ùå'} |`,",
    "            ].join('\\n') : '';",
    '',
    '            const body = [',
    '              marker,',
    '              `## ${statusEmoji} Remediation Agent ‚Äî ${statusText}`,',
    "              '',",
    '              `**Attempt**: ${attempt}`,',
    '              `**Source SHA**: \\`${headSha.slice(0, 12)}\\``,',
    "              newSha ? `**New SHA**: \\`${newSha.slice(0, 12)}\\`` : '',",
    "              '',",
    '              filesSection,',
    '              validationSection,',
    "              '',",
    "              '---',",
    "              '*ü§ñ [Remediation agent](https://github.com/codefactory) ‚Äî automated code fix.*',",
    "            ].filter(Boolean).join('\\n');",
    '',
    '            await github.rest.issues.createComment({',
    '              owner: context.repo.owner,',
    '              repo: context.repo.repo,',
    '              issue_number: prNumber,',
    '              body,',
    '            });',
  ];
  return lines.join('\n') + '\n';
}

function buildRemediationPrompt(lintCmd: string, testCmd: string): string {
  return `# Remediation Agent Instructions

You are a code remediation agent. Your task is to fix specific review findings on a pull request for a TypeScript (ESM) project.

## Rules

1. **Fix only what's reported**: Address ONLY the specific findings provided. Do not refactor surrounding code, add features, or "improve" things not mentioned in the findings.
2. **Minimal changes**: Make the smallest possible change that fully addresses each finding. Fewer changed lines = less risk.
3. **Preserve intent**: Understand the original author's intent and preserve it while fixing the issue.
4. **Run validation**: After making all changes, verify they compile correctly by reviewing your edits for syntax and type errors.
5. **Skip stale findings**: If a finding references code that no longer exists at HEAD, skip it and note why in your summary.
6. **Never bypass gates**: Do not modify CI configs, disable linters, add skip annotations (\`eslint-disable\`, \`@ts-ignore\`, \`@ts-expect-error\`), or circumvent quality gates.
7. **Pin to HEAD**: Only operate on files as they exist at the current HEAD SHA. Never use cached or assumed content ‚Äî always read the file first.
8. **Audit trail**: For each fix, record the original finding and what was changed.

## Code Style (enforced by project)

- **ESM**: All local imports must include \`.js\` extensions (e.g., \`import { foo } from './bar.js'\`).
- **Type imports**: Use \`import type { Foo }\` for type-only imports ‚Äî \`verbatimModuleSyntax\` is enabled.
- **Error handling**: Use \`error instanceof Error ? error.message : String(error)\` in catch blocks.
- **Naming**: \`camelCase\` for variables/functions, \`PascalCase\` for interfaces/classes/types.
- **Formatting**: Single quotes, semicolons, trailing commas, 2-space indent, 100-char line width.
- **Exports**: Named exports only. No default exports.

## Validation Commands

- **Lint**: \`${lintCmd}\`
- **Type check**: \`tsc --noEmit\`
- **Test**: \`${testCmd}\`

## Files You Must Never Modify

- \`.github/workflows/*\` ‚Äî CI/CD workflow files
- \`harness.config.json\` ‚Äî harness configuration
- \`CLAUDE.md\` ‚Äî project conventions
- \`package-lock.json\`, \`yarn.lock\`, \`pnpm-lock.yaml\` ‚Äî lock files
- \`package.json\`, \`tsconfig.json\`, \`tsup.config.ts\`, \`vitest.config.ts\`, \`eslint.config.js\` ‚Äî build infrastructure

## Architectural Boundaries

Respect import boundaries between layers:

| Layer | Allowed Imports |
|-------|----------------|
| \`utils\` | (nothing) |
| \`ui\` | \`utils\` |
| \`core\` | \`utils\` |
| \`commands\` | \`core\`, \`ui\`, \`utils\` |
| \`prompts\` | \`core\`, \`utils\` |
| \`providers\` | \`core\`, \`utils\` |
| \`harnesses\` | \`core\`, \`prompts\`, \`providers\`, \`utils\` |

Do not introduce imports that violate these boundaries.

## Workflow

1. Read each finding carefully ‚Äî note the file, line, severity, and description.
2. Read the target file to understand current state at HEAD.
3. Make the minimal edit to address the finding.
4. Move to the next finding.
5. After all edits, produce the JSON summary below.

## Output

After making fixes, output a single JSON object:

\`\`\`json
{
  "fixed": [
    {
      "file": "src/path/to/file.ts",
      "finding": "Original finding description",
      "change": "Brief description of what was changed"
    }
  ],
  "skipped": [
    {
      "file": "src/path/to/file.ts",
      "finding": "Original finding description",
      "reason": "Why this finding was skipped"
    }
  ],
  "filesModified": ["src/path/to/file.ts"]
}
\`\`\`

Do not output anything besides the JSON object. No markdown wrapping, no explanation ‚Äî just JSON.
`;
}

function buildRemediationGuard(): string {
  const lines = [
    '#!/usr/bin/env npx tsx',
    '// ============================================================================',
    '// Remediation Guard ‚Äî pre-flight gate for automated remediation',
    '//',
    '// Determines whether the remediation agent should proceed based on:',
    '//   - Remediation attempt count (tracked via PR labels)',
    '//   - Security-related findings (always require human review)',
    '//   - Protected file targets (never auto-remediated)',
    '//   - Strictness-level attempt limits',
    '//',
    '// Usage:',
    "//   PR_NUMBER=42 FINDINGS='[...]' npx tsx scripts/remediation-guard.ts --evaluate",
    '//   npx tsx scripts/remediation-guard.ts --self-test',
    '//',
    '// Environment variables:',
    '//   PR_NUMBER          ‚Äî PR number to evaluate',
    '//   FINDINGS           ‚Äî JSON array of review findings',
    '//   STRICTNESS         ‚Äî relaxed | standard | strict (default: relaxed)',
    '//   GITHUB_REPOSITORY  ‚Äî owner/repo (set by CI runner)',
    '//   GH_TOKEN           ‚Äî GitHub auth token for API calls',
    '// ============================================================================',
    '',
    "import { execSync } from 'node:child_process';",
    '',
    '// --- Types ---',
    '',
    'export interface Finding {',
    "  severity: 'blocking' | 'warning' | 'suggestion';",
    '  file: string;',
    '  line: number | null;',
    '  message: string;',
    '}',
    '',
    'export interface RemediationDecision {',
    '  shouldRemediate: boolean;',
    '  attemptNumber: number;',
    '  reason: string;',
    '  securityBlockers: string[];',
    '  skippedFindings: string[];',
    '}',
    '',
    '// --- Constants ---',
    '',
    '/** Maximum remediation attempts per PR, keyed by strictness level. */',
    'const MAX_ATTEMPTS: Record<string, number> = {',
    '  relaxed: 10,',
    '  standard: 5,',
    '  strict: 3,',
    '};',
    '',
    '/** Keywords that identify security-related findings. Case-insensitive matching. */',
    'const SECURITY_KEYWORDS = [',
    "  'security',",
    "  'injection',",
    "  'xss',",
    "  'ssrf',",
    "  'csrf',",
    "  'auth bypass',",
    "  'authentication',",
    "  'authorization',",
    "  'privilege escalation',",
    "  'secret',",
    "  'credential',",
    "  'token exposure',",
    "  'vulnerability',",
    "  'sanitize',",
    "  'unsanitized',",
    '];',
    '',
    '/** File patterns that the remediation agent must never modify. */',
    'const PROTECTED_FILE_PATTERNS = [',
    '  /^\\.github\\/workflows\\//',
    '  /^harness\\.config\\.json$/',
    '  /^CLAUDE\\.md$/',
    '  /^package-lock\\.json$/',
    '  /^yarn\\.lock$/',
    '  /^pnpm-lock\\.yaml$/',
    '  /^package\\.json$/',
    '  /^tsconfig\\.json$/',
    '  /^tsup\\.config\\.ts$/',
    '  /^vitest\\.config\\.ts$/',
    '  /^eslint\\.config\\.js$/',
    '];',
    '',
    '// --- Public API ---',
    '',
    '/**',
    ' * Check if a finding is security-related based on keyword matching.',
    ' * Security findings are never auto-remediated ‚Äî they require human review.',
    ' */',
    'export function isSecurityFinding(finding: Finding): boolean {',
    '  const msg = finding.message.toLowerCase();',
    '  return SECURITY_KEYWORDS.some((keyword) => msg.includes(keyword));',
    '}',
    '',
    '/**',
    ' * Check if a file path matches any protected file pattern.',
    ' * Protected files are never modified by the remediation agent.',
    ' */',
    'export function isProtectedFile(filePath: string): boolean {',
    '  return PROTECTED_FILE_PATTERNS.some((pattern) => pattern.test(filePath));',
    '}',
    '',
    '/**',
    ' * Query the current remediation attempt count from PR labels.',
    ' * Labels follow the pattern `remediation-attempt-N`.',
    ' * Returns the highest N found, or 0 if no labels match.',
    ' */',
    'export function getAttemptCount(prNumber: number): number {',
    '  try {',
    "    const repo = process.env.GITHUB_REPOSITORY || '';",
    '    if (!repo) return 0;',
    '',
    '    const output = execSync(',
    '      `gh pr view ${prNumber} --repo "${repo}" --json labels --jq \'.labels[].name\'`,',
    "      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] },",
    '    );',
    '',
    '    let maxAttempt = 0;',
    "    for (const label of output.trim().split('\\n')) {",
    '      const match = label.match(/^remediation-attempt-(\\d+)$/);',
    '      if (match) {',
    '        const num = parseInt(match[1], 10);',
    '        if (num > maxAttempt) maxAttempt = num;',
    '      }',
    '    }',
    '    return maxAttempt;',
    '  } catch {',
    '    return 0;',
    '  }',
    '}',
    '',
    '/**',
    ' * Format a finding into a human-readable string for audit logs.',
    ' */',
    'function formatFinding(finding: Finding, prefix: string): string {',
    '  const loc = finding.file',
    "    ? `${finding.file}${finding.line ? `:${finding.line}` : ''}`",
    "    : 'general';",
    '  return `[${prefix}] ${loc} ‚Äî ${finding.message}`;',
    '}',
    '',
    '/**',
    ' * Evaluate whether remediation should proceed for a given PR.',
    ' *',
    ' * Decision logic:',
    ' * 1. Check attempt limit ‚Äî reject if exceeded.',
    ' * 2. Separate security findings ‚Äî these are never auto-fixed.',
    ' * 3. Filter findings targeting protected files ‚Äî these are skipped.',
    ' * 4. If actionable findings remain, approve remediation.',
    ' */',
    'export function evaluate(',
    '  prNumber: number,',
    '  findings: Finding[],',
    '  strictness: string,',
    '): RemediationDecision {',
    '  const maxAttempts = MAX_ATTEMPTS[strictness] ?? MAX_ATTEMPTS.relaxed;',
    '  const currentAttempt = getAttemptCount(prNumber);',
    '  const nextAttempt = currentAttempt + 1;',
    '',
    '  // Gate 1: Attempt limit',
    '  if (nextAttempt > maxAttempts) {',
    '    return {',
    '      shouldRemediate: false,',
    '      attemptNumber: nextAttempt,',
    '      reason: `Remediation limit reached (${maxAttempts} attempts for ${strictness} mode). Human review required.`,',
    '      securityBlockers: [],',
    '      skippedFindings: [],',
    '    };',
    '  }',
    '',
    '  // Gate 2: Classify findings',
    '  const securityBlockers: string[] = [];',
    '  const skippedFindings: string[] = [];',
    '  const actionableFindings: Finding[] = [];',
    '',
    '  for (const finding of findings) {',
    '    if (isSecurityFinding(finding)) {',
    '      securityBlockers.push(formatFinding(finding, finding.severity));',
    '      continue;',
    '    }',
    '',
    '    if (finding.file && isProtectedFile(finding.file)) {',
    "      skippedFindings.push(formatFinding(finding, 'protected'));",
    '      continue;',
    '    }',
    '',
    '    actionableFindings.push(finding);',
    '  }',
    '',
    '  // Gate 3: All findings are security-related',
    '  if (actionableFindings.length === 0 && securityBlockers.length > 0) {',
    '    return {',
    '      shouldRemediate: false,',
    '      attemptNumber: nextAttempt,',
    "      reason: 'All findings are security-related and require human review.',",
    '      securityBlockers,',
    '      skippedFindings,',
    '    };',
    '  }',
    '',
    '  // Gate 4: No actionable findings',
    '  if (actionableFindings.length === 0) {',
    '    return {',
    '      shouldRemediate: false,',
    '      attemptNumber: nextAttempt,',
    "      reason: 'No actionable findings after filtering security and protected-file issues.',",
    '      securityBlockers,',
    '      skippedFindings,',
    '    };',
    '  }',
    '',
    '  return {',
    '    shouldRemediate: true,',
    '    attemptNumber: nextAttempt,',
    '    reason: `${actionableFindings.length} actionable finding(s) to remediate (attempt ${nextAttempt}/${maxAttempts}).`,',
    '    securityBlockers,',
    '    skippedFindings,',
    '  };',
    '}',
    '',
    '// --- CLI: --evaluate ---',
    '',
    "if (process.argv.includes('--evaluate')) {",
    "  const prNumber = parseInt(process.env.PR_NUMBER || '0', 10);",
    "  const strictness = process.env.STRICTNESS || 'relaxed';",
    '',
    '  if (!prNumber) {',
    "    console.error('ERROR: PR_NUMBER environment variable is required.');",
    '    process.exit(1);',
    '  }',
    '',
    '  let findings: Finding[] = [];',
    '  try {',
    "    findings = JSON.parse(process.env.FINDINGS || '[]');",
    '  } catch (error) {',
    '    const msg = error instanceof Error ? error.message : String(error);',
    '    console.error(`ERROR: Failed to parse FINDINGS JSON: ${msg}`);',
    '    process.exit(1);',
    '  }',
    '',
    '  const decision = evaluate(prNumber, findings, strictness);',
    '  console.log(JSON.stringify(decision, null, 2));',
    '}',
    '',
    '// --- CLI: --self-test ---',
    '',
    "if (process.argv.includes('--self-test')) {",
    "  console.log('Running remediation-guard self-test...\\n');",
    '',
    '  // --- isSecurityFinding ---',
    '  console.assert(',
    '    isSecurityFinding({',
    "      severity: 'blocking',",
    "      file: 'src/auth.ts',",
    '      line: 10,',
    "      message: 'SQL injection vulnerability in query builder',",
    '    }) === true,',
    "    'SQL injection should be detected as security finding',",
    '  );',
    '  console.assert(',
    '    isSecurityFinding({',
    "      severity: 'blocking',",
    "      file: 'src/api.ts',",
    '      line: 5,',
    "      message: 'Unsanitized user input passed to shell command',",
    '    }) === true,',
    "    'Unsanitized input should be detected as security finding',",
    '  );',
    '  console.assert(',
    '    isSecurityFinding({',
    "      severity: 'warning',",
    "      file: 'src/utils.ts',",
    '      line: 5,',
    "      message: 'Missing null check on optional parameter',",
    '    }) === false,',
    "    'Missing null check is not a security finding',",
    '  );',
    '  console.assert(',
    '    isSecurityFinding({',
    "      severity: 'suggestion',",
    "      file: 'src/ui.ts',",
    '      line: 20,',
    "      message: 'Consider using a Map instead of plain object',",
    '    }) === false,',
    "    'Code quality suggestion is not a security finding',",
    '  );',
    '',
    '  // --- isProtectedFile ---',
    '  console.assert(',
    "    isProtectedFile('.github/workflows/ci.yml') === true,",
    "    'CI workflow should be protected',",
    '  );',
    '  console.assert(',
    "    isProtectedFile('harness.config.json') === true,",
    "    'harness.config.json should be protected',",
    '  );',
    '  console.assert(',
    "    isProtectedFile('CLAUDE.md') === true,",
    "    'CLAUDE.md should be protected',",
    '  );',
    '  console.assert(',
    "    isProtectedFile('package-lock.json') === true,",
    "    'package-lock.json should be protected',",
    '  );',
    '  console.assert(',
    "    isProtectedFile('package.json') === true,",
    "    'package.json should be protected',",
    '  );',
    '  console.assert(',
    "    isProtectedFile('tsconfig.json') === true,",
    "    'tsconfig.json should be protected',",
    '  );',
    '  console.assert(',
    "    isProtectedFile('src/utils/helpers.ts') === false,",
    "    'Regular source file should not be protected',",
    '  );',
    '  console.assert(',
    "    isProtectedFile('tests/guard.test.ts') === false,",
    "    'Test file should not be protected',",
    '  );',
    '',
    '  // --- evaluate (without API calls ‚Äî uses attempt count of 0) ---',
    '  const mockFindings: Finding[] = [',
    '    {',
    "      severity: 'blocking',",
    "      file: 'src/utils/parser.ts',",
    '      line: 42,',
    "      message: 'Unhandled error in catch block ‚Äî will crash process',",
    '    },',
    '    {',
    "      severity: 'warning',",
    "      file: 'src/core/engine.ts',",
    '      line: 10,',
    "      message: 'SQL injection vulnerability in query',",
    '    },',
    '    {',
    "      severity: 'suggestion',",
    "      file: 'harness.config.json',",
    '      line: null,',
    "      message: 'Consider adding more patterns to tier2',",
    '    },',
    '  ];',
    '',
    '  // Patch getAttemptCount to avoid API calls in test',
    '  const originalGetAttemptCount = getAttemptCount;',
    '  const getAttemptCountMock = (): number => 0;',
    "  Object.defineProperty(globalThis, '_mockAttemptCount', { value: 0, writable: true });",
    '',
    '  // Test with mixed findings (relies on getAttemptCount returning 0 when no repo)',
    "  const decision = evaluate(0, mockFindings, 'relaxed');",
    '  console.assert(',
    '    decision.securityBlockers.length === 1,',
    '    `Expected 1 security blocker, got ${decision.securityBlockers.length}`,',
    '  );',
    '  console.assert(',
    '    decision.skippedFindings.length === 1,',
    '    `Expected 1 skipped finding, got ${decision.skippedFindings.length}`,',
    '  );',
    '  console.assert(',
    '    decision.shouldRemediate === true,',
    "    'Should remediate when actionable findings exist',",
    '  );',
    '',
    '  // Test all-security findings',
    '  const securityOnly = evaluate(',
    '    0,',
    '    [',
    '      {',
    "        severity: 'blocking',",
    "        file: 'src/auth.ts',",
    '        line: 1,',
    "        message: 'Authentication bypass in login handler',",
    '      },',
    '    ],',
    "    'relaxed',",
    '  );',
    '  console.assert(',
    '    securityOnly.shouldRemediate === false,',
    "    'Should NOT remediate when all findings are security-related',",
    '  );',
    '  console.assert(',
    "    securityOnly.reason.includes('security-related'),",
    "    'Reason should mention security',",
    '  );',
    '',
    '  // Test empty findings',
    "  const emptyDecision = evaluate(0, [], 'relaxed');",
    '  console.assert(',
    '    emptyDecision.shouldRemediate === false,',
    "    'Should NOT remediate with no findings',",
    '  );',
    '',
    "  console.log('\\n‚úî All self-tests passed.');",
    '}',
  ];
  return lines.join('\n') + '\n';
}
