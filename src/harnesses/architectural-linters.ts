import type { HarnessModule, HarnessContext, HarnessOutput } from './types.js';

import { buildArchitecturalLintersPrompt } from '../prompts/architectural-linters.js';
import { buildSystemPrompt } from '../prompts/system.js';

const LINT_ARCHITECTURE_SCRIPT =
  [
    '#!/usr/bin/env node',
    '/**',
    ' * Architectural Boundary Linter',
    ' *',
    ' * Enforces module dependency direction rules by statically analyzing import',
    ' * statements across the codebase. Rules are loaded from (in priority order):',
    ' *',
    ' *   1. scripts/lint-architecture-config.json  (dedicated override)',
    ' *   2. harness.config.json \u2192 architecturalBoundaries  (canonical source)',
    ' *   3. Built-in defaults matching CLAUDE.md layer hierarchy',
    ' *',
    ' * Uses regex-based import extraction (zero AST dependencies) and fast-glob',
    ' * for file discovery. Designed to run in < 2 s on a ~1 000-file project.',
    ' *',
    ' * Usage:',
    ' *   npx tsx scripts/lint-architecture.ts [options]',
    ' *',
    ' * Options:',
    ' *   --json       Output violations as JSON array',
    ' *   --summary    Output violation counts per layer pair only',
    ' *   --fix        Print refactoring hints for each violation',
    ' *   --verbose    Print every scanned file and its layer assignment',
    ' *',
    ' * Exit codes:',
    ' *   0  No violations',
    ' *   1  One or more violations found',
    ' *   2  Configuration or runtime error',
    ' */',
    '',
    "import { readFileSync, existsSync } from 'node:fs';",
    "import { dirname, join, relative, resolve } from 'node:path';",
    "import { fileURLToPath } from 'node:url';",
    "import fg from 'fast-glob';",
    '',
    '// ---------------------------------------------------------------------------',
    '// Types',
    '// ---------------------------------------------------------------------------',
    '',
    'interface LayerRule {',
    '  /** Layer name matching a directory under srcRoot (e.g. "commands"). */',
    '  name: string;',
    '  /** Glob patterns matching files in this layer. */',
    '  patterns: string[];',
    '  /** Layer names this layer is allowed to import from. */',
    '  canDependOn: string[];',
    '}',
    '',
    'interface Violation {',
    '  /** File path relative to repo root. */',
    '  file: string;',
    '  /** 1-based line number where the illegal import appears. */',
    '  line: number;',
    '  /** Raw import specifier (e.g. "../core/config.js"). */',
    '  importPath: string;',
    '  /** Layer the importing file belongs to. */',
    '  fromLayer: string;',
    '  /** Layer the import target resolves to. */',
    '  toLayer: string;',
    '  /** Human-readable description of the violated rule. */',
    '  rule: string;',
    '}',
    '',
    'interface LintResult {',
    '  violations: Violation[];',
    '  filesScanned: number;',
    '  /** Number of source files discovered per layer. */',
    '  layerCounts: Record<string, number>;',
    '}',
    '',
    'interface LintConfig {',
    '  layers: LayerRule[];',
    '  ignorePatterns: string[];',
    '  /** Comment token that exempts a line from checking. */',
    '  exemptComment: string;',
    '  /** Directory under repo root containing layer directories (default "src"). */',
    '  srcRoot: string;',
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// CLI argument parsing (no deps \u2014 just process.argv)',
    '// ---------------------------------------------------------------------------',
    '',
    'const args = new Set(process.argv.slice(2));',
    "const FLAG_JSON = args.has('--json');",
    "const FLAG_SUMMARY = args.has('--summary');",
    "const FLAG_FIX = args.has('--fix');",
    "const FLAG_VERBOSE = args.has('--verbose');",
    '',
    '// ---------------------------------------------------------------------------',
    '// Repo root discovery',
    '// ---------------------------------------------------------------------------',
    '',
    'function findRepoRoot(): string {',
    '  let dir = process.cwd();',
    '  while (dir !== dirname(dir)) {',
    "    if (existsSync(join(dir, 'package.json'))) return dir;",
    '    dir = dirname(dir);',
    '  }',
    '  return process.cwd();',
    '}',
    '',
    'const REPO_ROOT = findRepoRoot();',
    '',
    '// ---------------------------------------------------------------------------',
    '// Configuration loading (three-tier fallback)',
    '// ---------------------------------------------------------------------------',
    '',
    'function loadConfig(): LintConfig {',
    '  // --- Priority 1: dedicated config in scripts/ ---',
    "  const overridePath = join(REPO_ROOT, 'scripts', 'lint-architecture-config.json');",
    '  if (existsSync(overridePath)) {',
    '    try {',
    "      const raw = JSON.parse(readFileSync(overridePath, 'utf8'));",
    '      return {',
    '        layers: raw.layers,',
    '        ignorePatterns: raw.ignorePatterns ?? defaultIgnore(),',
    "        exemptComment: raw.exemptComment ?? 'arch-exempt',",
    "        srcRoot: raw.srcRoot ?? 'src',",
    '      };',
    '    } catch (err) {',
    '      fatal(`Failed to parse ${overridePath}: ${errMsg(err)}`);',
    '    }',
    '  }',
    '',
    '  // --- Priority 2: harness.config.json (canonical) ---',
    "  const harnessPath = join(REPO_ROOT, 'harness.config.json');",
    '  if (existsSync(harnessPath)) {',
    '    try {',
    "      const raw = JSON.parse(readFileSync(harnessPath, 'utf8'));",
    '      const boundaries: Record<string, { allowedImports?: string[] }> =',
    '        raw.architecturalBoundaries ?? {};',
    '      const layers: LayerRule[] = Object.entries(boundaries).map(([name, def]) => ({',
    '        name,',
    '        patterns: [`src/${name}/**`],',
    '        canDependOn: def.allowedImports ?? [],',
    '      }));',
    '      if (layers.length === 0) {',
    "        fatal('harness.config.json has no architecturalBoundaries entries');",
    '      }',
    '      return {',
    '        layers,',
    '        ignorePatterns: defaultIgnore(),',
    "        exemptComment: 'arch-exempt',",
    "        srcRoot: 'src',",
    '      };',
    '    } catch (err) {',
    '      fatal(`Failed to parse ${harnessPath}: ${errMsg(err)}`);',
    '    }',
    '  }',
    '',
    '  // --- Priority 3: built-in defaults (matches CLAUDE.md) ---',
    '  return {',
    '    layers: [',
    "      { name: 'commands', patterns: ['src/commands/**'], canDependOn: ['core', 'ui', 'utils'] },",
    "      { name: 'core', patterns: ['src/core/**'], canDependOn: ['utils'] },",
    '      {',
    "        name: 'harnesses',",
    "        patterns: ['src/harnesses/**'],",
    "        canDependOn: ['core', 'prompts', 'providers', 'utils'],",
    '      },',
    "      { name: 'prompts', patterns: ['src/prompts/**'], canDependOn: ['core', 'utils'] },",
    "      { name: 'providers', patterns: ['src/providers/**'], canDependOn: ['core', 'utils'] },",
    "      { name: 'ui', patterns: ['src/ui/**'], canDependOn: ['utils'] },",
    "      { name: 'utils', patterns: ['src/utils/**'], canDependOn: [] },",
    '    ],',
    '    ignorePatterns: defaultIgnore(),',
    "    exemptComment: 'arch-exempt',",
    "    srcRoot: 'src',",
    '  };',
    '}',
    '',
    'function defaultIgnore(): string[] {',
    "  return ['**/*.test.*', '**/*.spec.*', '**/fixtures/**', '**/__mocks__/**'];",
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// Layer resolution',
    '// ---------------------------------------------------------------------------',
    '',
    '/**',
    ' * Determine which architectural layer a file belongs to.',
    ' *',
    ' * Matches the first path segment after srcRoot/ against declared layer names.',
    ' * Returns null for files outside all layers (e.g. src/index.ts).',
    ' */',
    'function resolveFileLayer(filePath: string, layers: LayerRule[], srcRoot: string): string | null {',
    '  for (const layer of layers) {',
    '    if (filePath.startsWith(`${srcRoot}/${layer.name}/`)) return layer.name;',
    '  }',
    '  return null;',
    '}',
    '',
    '/**',
    ' * Resolve a relative import specifier to its target layer.',
    ' *',
    ' * Given file="src/commands/init.ts" and importPath="../core/config.js",',
    " * joins the file's directory with the import, normalizes the result, and",
    ' * checks which layer the resolved path falls into.',
    ' *',
    ' * Returns null for:',
    ' *   - Non-relative imports (bare specifiers like "chalk")',
    ' *   - Imports that resolve outside all declared layers',
    ' */',
    'function resolveImportLayer(',
    '  importPath: string,',
    '  importingFile: string,',
    '  layers: LayerRule[],',
    '  srcRoot: string,',
    '): string | null {',
    '  // Skip bare/absolute specifiers \u2014 only analyze relative imports',
    "  if (!importPath.startsWith('.')) return null;",
    '',
    '  // path.join normalizes ".." segments:',
    '  //   join("src/commands", "../core/config.js") \u2192 "src/core/config.js"',
    '  const resolved = join(dirname(importingFile), importPath);',
    '  return resolveFileLayer(resolved, layers, srcRoot);',
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// Import extraction (regex \u2014 no AST dependency)',
    '// ---------------------------------------------------------------------------',
    '',
    '// Matches `from \'./path\'` or `from "../path"` at end of import statements.',
    '// Captures only relative specifiers (starting with . or ..).',
    'const RE_FROM = /\\bfrom\\s+[\'"](\\.\\.?\\/[^\'"]+)[\'"]/;',
    '',
    "// Matches dynamic `import('./path')` expressions.",
    'const RE_DYNAMIC = /\\bimport\\(\\s*[\'"](\\.\\.?\\/[^\'"]+)[\'"]\\s*\\)/;',
    '',
    "// Matches CommonJS `require('./path')` calls.",
    'const RE_REQUIRE = /\\brequire\\(\\s*[\'"](\\.\\.?\\/[^\'"]+)[\'"]\\s*\\)/;',
    '',
    'const IMPORT_REGEXES = [RE_FROM, RE_DYNAMIC, RE_REQUIRE];',
    '',
    'interface ExtractedImport {',
    '  path: string;',
    '  line: number;',
    '}',
    '',
    '/**',
    ' * Extract all relative import specifiers from a source string.',
    ' * Scans line-by-line with three regex patterns \u2014 fast and dependency-free.',
    ' */',
    'function extractImports(source: string): ExtractedImport[] {',
    '  const results: ExtractedImport[] = [];',
    "  const lines = source.split('\\n');",
    '',
    '  for (let i = 0; i < lines.length; i++) {',
    '    const lineText = lines[i];',
    '    for (const re of IMPORT_REGEXES) {',
    '      const match = re.exec(lineText);',
    '      if (match) {',
    '        results.push({ path: match[1], line: i + 1 });',
    '      }',
    '    }',
    '  }',
    '',
    '  return results;',
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// Core lint engine',
    '// ---------------------------------------------------------------------------',
    '',
    'async function lint(config: LintConfig): Promise<LintResult> {',
    '  const violations: Violation[] = [];',
    '  const layerCounts: Record<string, number> = {};',
    '',
    '  for (const layer of config.layers) {',
    '    layerCounts[layer.name] = 0;',
    '  }',
    '',
    '  // Pre-compute allow-set per layer for O(1) lookup',
    '  const allowMap = new Map<string, Set<string>>();',
    '  for (const layer of config.layers) {',
    '    allowMap.set(layer.name, new Set(layer.canDependOn));',
    '  }',
    '',
    '  // Set of known layer names for target validation',
    '  const knownLayers = new Set(config.layers.map((l) => l.name));',
    '',
    '  // Discover .ts files under each declared layer directory',
    '  const globs = config.layers.map((l) => `${config.srcRoot}/${l.name}/**/*.ts`);',
    '',
    '  const files = await fg(globs, {',
    '    cwd: REPO_ROOT,',
    "    ignore: ['node_modules/**', 'dist/**', 'build/**', '.git/**', ...config.ignorePatterns],",
    '    absolute: false,',
    '  });',
    '',
    '  for (const file of files) {',
    '    const fromLayer = resolveFileLayer(file, config.layers, config.srcRoot);',
    '    if (!fromLayer) continue;',
    '',
    '    layerCounts[fromLayer]++;',
    '',
    '    if (FLAG_VERBOSE) {',
    '      process.stderr.write(`  [${fromLayer}] ${file}\\n`);',
    '    }',
    '',
    '    const absPath = join(REPO_ROOT, file);',
    "    const source = readFileSync(absPath, 'utf8');",
    '    const imports = extractImports(source);',
    "    const lines = source.split('\\n');",
    '    const allowed = allowMap.get(fromLayer)!;',
    '',
    '    for (const imp of imports) {',
    '      // Check for inline exemption comment',
    "      const lineText = lines[imp.line - 1] ?? '';",
    '      if (lineText.includes(`// ${config.exemptComment}`)) continue;',
    '',
    '      const toLayer = resolveImportLayer(imp.path, file, config.layers, config.srcRoot);',
    '',
    '      // Skip: external import, unresolved, or same-layer',
    '      if (!toLayer) continue;',
    '      if (toLayer === fromLayer) continue;',
    '',
    "      // Skip if the target isn't a known layer (e.g. vendor dirs)",
    '      if (!knownLayers.has(toLayer)) continue;',
    '',
    '      if (!allowed.has(toLayer)) {',
    "        const allowedList = [...allowed].sort().join(', ') || 'none';",
    '        violations.push({',
    '          file,',
    '          line: imp.line,',
    '          importPath: imp.path,',
    '          fromLayer,',
    '          toLayer,',
    '          rule: `"${fromLayer}" cannot import from "${toLayer}" (allowed: [${allowedList}])`,',
    '        });',
    '      }',
    '    }',
    '  }',
    '',
    '  return { violations, filesScanned: files.length, layerCounts };',
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// Output formatters',
    '// ---------------------------------------------------------------------------',
    '',
    'function printHumanReadable(result: LintResult, config: LintConfig): void {',
    '  const { violations, filesScanned, layerCounts } = result;',
    '',
    "  console.log('\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557');",
    "  console.log('\u2551   Architectural Boundary Linter                  \u2551');",
    "  console.log('\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d');",
    '  console.log();',
    '  console.log(`Files scanned: ${filesScanned}`);',
    '  console.log(',
    '    `Layers: ${Object.entries(layerCounts)',
    '      .map(([k, v]) => `${k} (${v})`)',
    "      .join(', ')}`,",
    '  );',
    '  console.log();',
    '',
    '  if (violations.length === 0) {',
    '    console.log(`\u2714 All architectural boundaries respected (${config.layers.length} layers checked)`);',
    '    return;',
    '  }',
    '',
    '  console.log(`\u2718 Found ${violations.length} violation(s):\\n`);',
    '',
    '  for (const v of violations) {',
    '    console.log(`  VIOLATION: ${v.file}:${v.line}`);',
    '    console.log(`    Import: ${v.importPath}`);',
    '    console.log(`    Rule:   ${v.rule}`);',
    '    if (FLAG_FIX) {',
    '      console.log(`    Fix:    ${suggestFix(v, config)}`);',
    '    }',
    '    console.log();',
    '  }',
    '',
    "  console.log('To fix: update the import to use an allowed module, or update');",
    "  console.log('architecturalBoundaries in harness.config.json if the dependency is intentional.');",
    "  console.log('To exempt a single line, add: // arch-exempt: <reason>');",
    '}',
    '',
    'function printSummary(result: LintResult): void {',
    '  const { violations } = result;',
    '  if (violations.length === 0) {',
    "    console.log('\u2714 No violations.');",
    '    return;',
    '  }',
    '',
    '  // Group by fromLayer \u2192 toLayer',
    '  const counts = new Map<string, number>();',
    '  for (const v of violations) {',
    '    const key = `${v.fromLayer} \u2192 ${v.toLayer}`;',
    '    counts.set(key, (counts.get(key) ?? 0) + 1);',
    '  }',
    '',
    '  console.log(`\u2718 ${violations.length} violation(s) across ${counts.size} layer pair(s):\\n`);',
    '  for (const [pair, count] of [...counts.entries()].sort()) {',
    '    console.log(`  ${pair}: ${count}`);',
    '  }',
    '}',
    '',
    'function printJson(result: LintResult): void {',
    '  console.log(JSON.stringify(result.violations, null, 2));',
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// Fix suggestions',
    '// ---------------------------------------------------------------------------',
    '',
    '/**',
    ' * Generate a human-readable refactoring hint for a violation.',
    ' *',
    ' * Strategies suggested (in order of preference):',
    ' *   1. Route through an intermediary layer that both sides can access.',
    ' *   2. Extract shared types/interfaces into the lowest common layer.',
    ' *   3. Widen the boundary rule if the dependency is architecturally sound.',
    ' */',
    'function suggestFix(v: Violation, config: LintConfig): string {',
    '  const fromRule = config.layers.find((l) => l.name === v.fromLayer);',
    '  const toRule = config.layers.find((l) => l.name === v.toLayer);',
    "  if (!fromRule || !toRule) return 'Review the import and update layer rules.';",
    '',
    "  // Check if there's an intermediary: a layer that fromLayer CAN depend on",
    '  // and that itself CAN depend on toLayer.',
    '  const intermediaries: string[] = [];',
    '  for (const allowed of fromRule.canDependOn) {',
    '    const intermediary = config.layers.find((l) => l.name === allowed);',
    '    if (intermediary && intermediary.canDependOn.includes(v.toLayer)) {',
    '      intermediaries.push(allowed);',
    '    }',
    '  }',
    '',
    '  if (intermediaries.length > 0) {',
    '    return (',
    '      `Route through "${intermediaries[0]}" layer \u2014 move the logic that depends on ` +',
    '      `"${v.toLayer}" into ${config.srcRoot}/${intermediaries[0]}/ ` +',
    '      `and import from there instead.`',
    '    );',
    '  }',
    '',
    '  // Check if the import is type-only \u2014 widening may be safe for types',
    "  // (We don't have AST info, but the import path heuristic is sufficient)",
    "  const fromAllowedStr = fromRule.canDependOn.join(', ') || 'none';",
    '  return (',
    '    `Either extract shared types into a layer both "${v.fromLayer}" and "${v.toLayer}" ` +',
    '    `can access (e.g. "utils"), or add "${v.toLayer}" to ` +',
    '    `${v.fromLayer}.canDependOn in harness.config.json ` +',
    '    `(currently: [${fromAllowedStr}]).`',
    '  );',
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// Helpers',
    '// ---------------------------------------------------------------------------',
    '',
    'function errMsg(err: unknown): string {',
    '  return err instanceof Error ? err.message : String(err);',
    '}',
    '',
    'function fatal(message: string): never {',
    '  console.error(`ERROR: ${message}`);',
    '  process.exit(2);',
    '}',
    '',
    '// ---------------------------------------------------------------------------',
    '// Main',
    '// ---------------------------------------------------------------------------',
    '',
    'async function main(): Promise<void> {',
    '  const config = loadConfig();',
    '',
    '  if (FLAG_VERBOSE) {',
    '    console.error(`Config loaded: ${config.layers.length} layers, srcRoot="${config.srcRoot}"`);',
    '    for (const l of config.layers) {',
    "      console.error(`  ${l.name} \u2192 canDependOn: [${l.canDependOn.join(', ')}]`);",
    '    }',
    '    console.error();',
    '  }',
    '',
    '  const result = await lint(config);',
    '',
    '  if (FLAG_JSON) {',
    '    printJson(result);',
    '  } else if (FLAG_SUMMARY) {',
    '    printSummary(result);',
    '  } else {',
    '    printHumanReadable(result, config);',
    '  }',
    '',
    '  process.exit(result.violations.length > 0 ? 1 : 0);',
    '}',
    '',
    'main().catch((err) => {',
    '  fatal(errMsg(err));',
    '});',
  ].join('\n') + '\n';

/**
 * Build the lint-architecture-config.json content dynamically from detected layers.
 */
function buildConfigJson(layers: string[]): string {
  const layerRules = layers.map((name) => ({
    name,
    patterns: [`src/${name}/**`],
    canDependOn: [] as string[],
  }));

  // Apply sensible defaults for common layer names.
  // If a layer is "utils", it depends on nothing.
  // Otherwise, every layer can depend on "utils" if it exists.
  const hasUtils = layers.includes('utils');
  const hasCore = layers.includes('core');

  for (const rule of layerRules) {
    switch (rule.name) {
      case 'utils':
        rule.canDependOn = [];
        break;
      case 'ui':
        rule.canDependOn = hasUtils ? ['utils'] : [];
        break;
      case 'core':
        rule.canDependOn = hasUtils ? ['utils'] : [];
        break;
      case 'commands':
        rule.canDependOn = [
          ...(hasCore ? ['core'] : []),
          ...(layers.includes('ui') ? ['ui'] : []),
          ...(hasUtils ? ['utils'] : []),
        ];
        break;
      case 'prompts':
        rule.canDependOn = [...(hasCore ? ['core'] : []), ...(hasUtils ? ['utils'] : [])];
        break;
      case 'providers':
        rule.canDependOn = [...(hasCore ? ['core'] : []), ...(hasUtils ? ['utils'] : [])];
        break;
      case 'harnesses':
        rule.canDependOn = [
          ...(hasCore ? ['core'] : []),
          ...(layers.includes('prompts') ? ['prompts'] : []),
          ...(layers.includes('providers') ? ['providers'] : []),
          ...(hasUtils ? ['utils'] : []),
        ];
        break;
      default:
        // Unknown layer -- allow utils and core as safe defaults
        rule.canDependOn = [...(hasCore ? ['core'] : []), ...(hasUtils ? ['utils'] : [])];
        break;
    }
  }

  const config = {
    srcRoot: 'src',
    layers: layerRules,
    ignorePatterns: ['**/*.test.*', '**/*.spec.*', '**/fixtures/**', '**/__mocks__/**'],
    exemptComment: 'arch-exempt',
  };

  return JSON.stringify(config, null, 2) + '\n';
}

export const architecturalLintersHarness: HarnessModule = {
  name: 'architectural-linters',
  displayName: 'Architectural Linters',
  description:
    'Generates custom linter scripts enforcing dependency direction and module boundaries',
  order: 11,

  isApplicable(ctx: HarnessContext): boolean {
    return ctx.detection.architecturalLayers.length > 0;
  },

  async execute(ctx: HarnessContext): Promise<HarnessOutput> {
    const { detection, userPreferences } = ctx;

    // 1. Generate reference templates from existing builders/constants
    const refLintScript = LINT_ARCHITECTURE_SCRIPT;
    const refConfig = buildConfigJson(detection.architecturalLayers);

    // 2. Build the prompt with reference context
    const basePrompt = buildArchitecturalLintersPrompt(detection, userPreferences);
    const prompt = `${basePrompt}

## Reference Implementation

Use these as your structural template. Keep the same patterns but customize all
language setup, install commands, test/lint/build commands, and tooling for the
detected stack.

### Reference: scripts/lint-architecture.ts
\`\`\`typescript
${refLintScript}
\`\`\`

### Reference: scripts/lint-architecture-config.json
\`\`\`json
${refConfig}
\`\`\``;

    // 3. Call Claude runner
    const systemPrompt = buildSystemPrompt(ctx.runner.platform);
    try {
      const result = await ctx.runner.generate(prompt, systemPrompt);
      const output: HarnessOutput = {
        harnessName: 'architectural-linters',
        filesCreated: result.filesCreated,
        filesModified: result.filesModified,
        metadata: { linterPath: 'scripts/lint-architecture.sh' },
      };
      ctx.previousOutputs.set('architectural-linters', output);
      return output;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Architectural linters generation failed: ${message}`);
    }
  },
};
